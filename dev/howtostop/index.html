<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>How to Stop · Stopping.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stopping.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../api/">API</a></li><li><a class="tocitem" href="../idcard/">Stopping&#39;s ID</a></li><li><a class="tocitem" href="../idcard-state/">State&#39;s ID</a></li><li><a class="tocitem" href="../idcard-stoppingmeta/">Meta&#39;s ID</a></li><li><a class="tocitem" href="../howstopcheckoptimality/">Optimality in Stopping</a></li><li><a class="tocitem" href="../example-basic-Newton/">Stopping in action</a></li><li><a class="tocitem" href="../idcard-stopremote/">Stop remote control</a></li><li><a class="tocitem" href="../stop-workflow/">Stopping workflow</a></li><li><a class="tocitem" href="../speak-to-stopping/">Speak to stopping</a></li><li><a class="tocitem" href="../nlpstopping/">NLPStopping</a></li><li><a class="tocitem" href="../lastopping/">LAStopping</a></li><li><a class="tocitem" href="../index_tuto/">Readme</a></li><li><a class="tocitem" href="../howtostate/">How to State</a></li><li><a class="tocitem" href="../howtostate-nlp/">How to State for NLPs</a></li><li class="is-active"><a class="tocitem" href>How to Stop</a><ul class="internal"><li><a class="tocitem" href="#How-to-Stop"><span>How to Stop</span></a></li></ul></li><li><a class="tocitem" href="../howtostop-2/">How to Stop 2</a></li><li><a class="tocitem" href="../howtostop-nlp/">How to Stop for NLPs</a></li><li><a class="tocitem" href="../linear-algebra/">Solve linear algebra</a></li><li><a class="tocitem" href="../buffer/">Use a buffer function</a></li><li><a class="tocitem" href="../fixed-point/">A fixed point algorithm</a></li><li><a class="tocitem" href="../backls/">Backtracking linesearch algorithm</a></li><li><a class="tocitem" href="../uncons/">Unconstrained optimization algorithm</a></li><li><a class="tocitem" href="../active-set/">Active set algorithm</a></li><li><a class="tocitem" href="../penalty/">Quadratic penalty algorithm</a></li><li><a class="tocitem" href="../run-optimsolver/">Run optimization algorithms</a></li><li><a class="tocitem" href="../benchmark/">Benchmark optimization algorithms</a></li><li><a class="tocitem" href="../overfitting/">Overfitting</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../gradient-lbfgs/">Mix algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>How to Stop</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>How to Stop</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/master/docs/src/howtostop.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="How-to-Stop"><a class="docs-heading-anchor" href="#How-to-Stop">How to Stop</a><a id="How-to-Stop-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-Stop" title="Permalink"></a></h2><p>The Stopping structure eases the implementation of algorithms and the stopping criterion. We illustrate here the basic features of Stopping.</p><p>-&gt; the case where a Stopping is a sub-Stopping is treated in the next tutorial.</p><p>The Julia file corresponding to this tutorial can be found <a href="https://github.com/Goysa2/Stopping.jl/tree/master/test/examples/howtostop.jl">here</a>.</p><pre><code class="nohighlight hljs">using Test, Stopping</code></pre><pre><code class="nohighlight hljs">x0 = ones(2)
pb = nothing</code></pre><h3 id="I.-Initialize-a-Stopping"><a class="docs-heading-anchor" href="#I.-Initialize-a-Stopping">I. Initialize a Stopping</a><a id="I.-Initialize-a-Stopping-1"></a><a class="docs-heading-anchor-permalink" href="#I.-Initialize-a-Stopping" title="Permalink"></a></h3><p>The lazy way to initialize the stopping is to provide an initial point:</p><pre><code class="nohighlight hljs">stop1 = GenericStopping(pb, x0, rtol = 1e-1)</code></pre><p>The more sophisticated way is to first build a State:</p><pre><code class="nohighlight hljs">state1 = GenericState(ones(2))</code></pre><p>then, use it to create a Stopping:</p><pre><code class="nohighlight hljs">stop2 = GenericStopping(pb, state1, rtol = 1e-1)</code></pre><p>Both ways give the same result:</p><pre><code class="nohighlight hljs">@test stop1.current_state.x == stop2.current_state.x
@test stop1.current_state.current_time == stop2.current_state.current_time</code></pre><p>Keywords given in the Stopping creator are forwarded to the StoppingMeta.</p><pre><code class="nohighlight hljs">@test stop1.meta.rtol == 1e-1</code></pre><h3 id="II.-Check-the-status"><a class="docs-heading-anchor" href="#II.-Check-the-status">II. Check the status</a><a id="II.-Check-the-status-1"></a><a class="docs-heading-anchor-permalink" href="#II.-Check-the-status" title="Permalink"></a></h3><p>To ask the Stopping what is the current situation, we have the status function:</p><pre><code class="nohighlight hljs">@test status(stop1) == :Unknown #nothing happened yet.</code></pre><p>The status function check the boolean values in the Meta: unbounded, unbounded<em>pb, tired, stalled, iteration</em>limit, resources, optimal, infeasible, main_pb, domainerror, suboptimal</p><pre><code class="nohighlight hljs">stop1.meta.unbounded  = true
stop1.meta.suboptimal = true</code></pre><p>By default the status function prioritizes a status:</p><pre><code class="nohighlight hljs">@test status(stop1) == :SubOptimal</code></pre><p>while you can access the list of status by turning the keyword list as true:</p><pre><code class="nohighlight hljs">@test status(stop1, list =true) == [:SubOptimal, :Unbounded]</code></pre><h3 id="III.-Analyze-the-situation:-start!"><a class="docs-heading-anchor" href="#III.-Analyze-the-situation:-start!">III. Analyze the situation: start!</a><a id="III.-Analyze-the-situation:-start!-1"></a><a class="docs-heading-anchor-permalink" href="#III.-Analyze-the-situation:-start!" title="Permalink"></a></h3><p>Two functions are designed to ask Stopping to analyze the current situation mainly described by the State: start!, stop! start! is designed to be used right at the beginning of the algorithm:</p><pre><code class="nohighlight hljs">start!(stop1) #we will compare with stop2</code></pre><p>this call initializes a few entries: a) start_time in the META</p><pre><code class="nohighlight hljs">@test isnan(stop2.meta.start_time)
@test !isnan(stop1.meta.start_time)</code></pre><p>b) optimality0 in the META (used to check the relative error)</p><pre><code class="nohighlight hljs">@test stop2.meta.optimality0 == 1.0 #default value was 1.0
@test stop1.meta.optimality0 == Inf #GenericStopping has no specified measure</code></pre><p>c) the time measured is also updated in the State (if void)</p><pre><code class="nohighlight hljs">@test stop1.current_state.current_time != nothing</code></pre><p>d) in the case where optimality0 is NaN, meta.domainerror becomes true</p><pre><code class="nohighlight hljs">@test stop1.meta.domainerror == false</code></pre><p>e) the problem would be already solved if optimality0 pass a null_test Since optimality0 is Inf, any value would pass the relative error check:</p><pre><code class="nohighlight hljs">@test Stopping._null_test(stop1, Inf) == true
@test stop1.meta.optimal == true
@test :Optimal in status(stop1, list = true)</code></pre><p>The Stopping determines the optimality by testing a score at zero. The test at zero is controlled by the function meta.tol_check which takes 3 arguments: atol, rtol, optimality0. By default it check if the score is less than: max(atol, rtol * opt0)</p><pre><code class="nohighlight hljs">stop1.meta.tol_check = (atol, rtol, opt0) -&gt; atol
@test Stopping._null_test(stop1, Inf) == false</code></pre><p>This can be determined in the initialization of the Stopping</p><pre><code class="nohighlight hljs">stop3 = GenericStopping(pb, state1, tol_check = (atol, rtol, opt0) -&gt; atol)
@test Stopping._null_test(stop3, Inf) == false</code></pre><p>The function _optimality<em>check providing the score returns Inf by default and must be specialized for specialized Stopping. If State entries have to be specified before the start!, you can use the function update</em>and_start! instead of a update! and then a start!</p><pre><code class="nohighlight hljs">update_and_start!(stop3, x = zeros(2), current_time = -1.0)
@test stop3.meta.optimal == false
@test stop3.current_state.current_time == -1.0
@test stop3.meta.start_time != nothing
@test stop3.current_state.x == zeros(2)</code></pre><p>Once the iterations begins #stop! is the main function. if needed an update is needed first, we can use update<em>and</em>stop!</p><pre><code class="nohighlight hljs">OK = stop!(stop3) #update the Stopping and return  a boolean
@test OK == false #no reason to stop just yet!</code></pre><p>The stop! call check the following:</p><ol><li>meta.domainerror: check if the score is NaN</li><li>meta.optimal: the score passes the _null_test</li><li>meta.unbounded: check if state.x is too large</li><li>meta.unbounded_pb: false by default</li><li>meta.tired: check if time is exhausted</li><li>meta.resources: false by default</li><li>meta.iteration_limit: check the number of iterations</li><li>meta.stalled: false by default</li><li>meta.main_pb: false by default -&gt; see Stopping as a subproblem tutorial</li></ol><p>Note that 1 and 2 are also done by start!.</p><ol><li>check unboundedness of x:</li></ol><pre><code class="nohighlight hljs">@test update_and_stop!(stop3, x = (stop3.meta.unbounded_x + 1.0) * x0 )
@test stop3.meta.unbounded == true</code></pre><ol><li>check time</li></ol><pre><code class="nohighlight hljs">stop3.meta.start_time = 0.0 #too  force the time limit.
stop!(stop3)
@test stop3.meta.tired == true</code></pre><ol><li>Stopping the number of iterations by the number of calls to stop!</li></ol><pre><code class="nohighlight hljs">@test stop3.meta.nb_of_stop == 3 #We called stop3 3 times already
stop3.meta.max_iter = 3
stop!(stop3)
@test stop3.meta.iteration_limit == true #as stop3.meta.nb_of_stop &gt; 3.</code></pre><p>Overall we activated three flags:</p><pre><code class="nohighlight hljs">@test status(stop3, list = true) == [:Unbounded, :IterationLimit, :Tired]</code></pre><p>Once we are done with an algorithm and want to reuse a stopping, we need to reinitialize all the entries.</p><pre><code class="nohighlight hljs">reinit!(stop3)</code></pre><p>the status boolean are back to false</p><pre><code class="nohighlight hljs">@test !stop3.meta.iteration_limit &amp;&amp; !stop3.meta.tired &amp;&amp; !stop3.meta.unbounded</code></pre><p>reinitialize also the entries updated by the start!</p><pre><code class="nohighlight hljs">@test isnan(stop3.meta.start_time) &amp;&amp; (stop3.meta.optimality0 == 1.0)
@test stop3.meta.nb_of_stop == 0 #and the counter of stop</code></pre><p>Note that by default reinit! does not reinitialize the current<em>state. This can be done by switching the keyword rstate to true. In this case, keywords are forwarded to the reinit! of current</em>state.</p><pre><code class="nohighlight hljs">reinit!(stop3, rstate =  true, x = zeros(2))
@test stop3.current_state.current_time == nothing
@test stop3.current_state.x == zeros(2)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../howtostate-nlp/">« How to State for NLPs</a><a class="docs-footer-nextpage" href="../howtostop-2/">How to Stop 2 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 31 October 2022 19:18">Monday 31 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
