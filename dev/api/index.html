<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Stopping.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stopping.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions"><span>General Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Stopping"><span>Stopping</span></a></li><li><a class="tocitem" href="#Types-2"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions-2"><span>General Functions</span></a></li><li><a class="tocitem" href="#Non-linear-admissibility-functions"><span>Non-linear admissibility functions</span></a></li><li><a class="tocitem" href="#Linear-algebra-admissibility-functions"><span>Linear algebra admissibility functions</span></a></li><li><a class="tocitem" href="#Line-search-admissibility-functions"><span>Line search admissibility functions</span></a></li></ul></li><li><a class="tocitem" href="../idcard/">Stopping&#39;s ID</a></li><li><a class="tocitem" href="../idcard-state/">State&#39;s ID</a></li><li><a class="tocitem" href="../idcard-stoppingmeta/">Meta&#39;s ID</a></li><li><a class="tocitem" href="../howstopcheckoptimality/">Optimality in Stopping</a></li><li><a class="tocitem" href="../example-basic-Newton/">Stopping in action</a></li><li><a class="tocitem" href="../idcard-stopremote/">Stop remote control</a></li><li><a class="tocitem" href="../stop-workflow/">Stopping workflow</a></li><li><a class="tocitem" href="../speak-to-stopping/">Speak to stopping</a></li><li><a class="tocitem" href="../nlpstopping/">NLPStopping</a></li><li><a class="tocitem" href="../lastopping/">LAStopping</a></li><li><a class="tocitem" href="../index_tuto/">Readme</a></li><li><a class="tocitem" href="../howtostate/">How to State</a></li><li><a class="tocitem" href="../howtostate-nlp/">How to State for NLPs</a></li><li><a class="tocitem" href="../howtostop/">How to Stop</a></li><li><a class="tocitem" href="../howtostop-2/">How to Stop 2</a></li><li><a class="tocitem" href="../howtostop-nlp/">How to Stop for NLPs</a></li><li><a class="tocitem" href="../linear-algebra/">Solve linear algebra</a></li><li><a class="tocitem" href="../buffer/">Use a buffer function</a></li><li><a class="tocitem" href="../fixed-point/">A fixed point algorithm</a></li><li><a class="tocitem" href="../backls/">Backtracking linesearch algorithm</a></li><li><a class="tocitem" href="../uncons/">Unconstrained optimization algorithm</a></li><li><a class="tocitem" href="../active-set/">Active set algorithm</a></li><li><a class="tocitem" href="../penalty/">Quadratic penalty algorithm</a></li><li><a class="tocitem" href="../run-optimsolver/">Run optimization algorithms</a></li><li><a class="tocitem" href="../benchmark/">Benchmark optimization algorithms</a></li><li><a class="tocitem" href="../overfitting/">Overfitting</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../gradient-lbfgs/">Mix algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericState" href="#Stopping.GenericState"><code>Stopping.GenericState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: <code>GenericState</code></p><p>Methods: <code>update!</code>, <code>reinit!</code></p><p>A generic State to describe the state of a problem at a point x.</p><p>Tracked data include:</p><ul><li>x             : current iterate</li><li>d [opt]       : search direction</li><li>res [opt]     : residual</li><li>current_time  : time</li><li>current_score : score</li></ul><p>Constructors:     <code>GenericState(:: T, :: S; d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;:AbstractVector}</code></p><pre><code class="nohighlight hljs">`GenericState(:: T; d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where T &lt;:AbstractVector`</code></pre><p>Note: </p><ul><li>By default, unknown entries are set using <code>_init_field</code>.</li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.  To have a vectorized <code>current_score</code> of length n, try something like <code>GenericState(x, Array{eltype(x),1}(undef, n))</code>.</li></ul><p>Examples:   <code>GenericState(x)</code>   <code>GenericState(x, Array{eltype(x),1}(undef, length(x)))</code>   <code>GenericState(x, current_time = 1.0)</code>      <code>GenericState(x, current_score = 1.0)</code></p><p>See also: <code>Stopping</code>, <code>NLPAtX</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/GenericStatemod.jl#L18-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.ListofStates" href="#Stopping.ListofStates"><code>Stopping.ListofStates</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: list of States</p><p>Constructor:</p><p><code>ListofStates(:: AbstractState)</code></p><p><code>ListofStates(n :: Int, :: Val{AbstractState})</code></p><p><code>ListofStates(n :: Int, list :: Array{AbstractState,1})</code></p><p><code>ListofStates(state :: S; n :: Int = -1, kwargs...)</code></p><p>Note:</p><ul><li>If <code>n != -1</code>, then it stores at most n <code>AbstractState</code>.</li><li><code>ListofStates</code> recursively handles sub-list of states as the attribute list is</li></ul><p>an array of pair whose first component is a, <code>AbstractState</code> and the second component is a <code>ListofStates</code> (or <code>VoidListofStates</code>).</p><p>Examples: <code>ListofStates(state)</code>     <code>ListofStates(state, n = 2)</code>     <code>ListofStates(-1, Val{NLPAtX}())</code>     <code>ListofStates(-1, [(state1, VoidListofStates), (state2, VoidListofStates)], 2)</code>    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/ListOfStates.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPAtX" href="#Stopping.NLPAtX"><code>Stopping.NLPAtX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPAtX</p><p>Methods: update!, reinit!</p><p>NLPAtX contains the information concerning a nonlinear optimization model at the iterate x.</p><p>min_{x ∈ ℜⁿ} f(x) subject to lcon &lt;= c(x) &lt;= ucon, lvar &lt;= x &lt;= uvar.</p><p>Tracked data include:</p><ul><li><p>x             : the current iterate</p></li><li><p>fx [opt]      : function evaluation at x</p></li><li><p>gx [opt]      : gradient evaluation at x</p></li><li><p>Hx [opt]      : hessian evaluation at x</p></li><li><p>mu [opt]      : Lagrange multiplier of the bounds constraints</p></li><li><p>cx [opt]      : evaluation of the constraint function at x</p></li><li><p>Jx [opt]      : jacobian matrix of the constraint function at x</p></li><li><p>lambda        : Lagrange multiplier of the constraints</p></li><li><p>d [opt]       : search direction</p></li><li><p>res [opt]     : residual</p></li><li><p>current_time  : time</p></li><li><p>current_score : score</p></li></ul><p>(import the type NLPModels.Counters)</p><p>Constructors:  <code>NLPAtX(:: T, :: T, :: S; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), cx :: T = _init_field(T), Jx :: SparseMatrixCSC{eltype(T), Int64} = _init_field(SparseMatrixCSC{eltype(T), Int64}), d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;: AbstractVector}</code></p><p><code>NLPAtX(:: T; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where {T &lt;: AbstractVector}</code></p><p><code>NLPAtX(:: T, :: T; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), cx :: T = _init_field(T), Jx :: SparseMatrixCSC{eltype(T), Int64} = _init_field(SparseMatrixCSC{eltype(T), Int64}), d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64  = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where T &lt;: AbstractVector</code></p><p>Note:</p><ul><li>By default, unknown entries are set using <code>_init_field</code>.  </li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.    To have a vectorized <code>current_score</code> of length n, try something like <code>GenericState(x, Array{eltype(x),1}(undef, n))</code>.  </li><li>All these information (except for <code>x</code> and <code>lambda</code>) are optionnal and need to be update when  required. The update is done through the <code>update!</code> function.  </li><li><code>x</code> and <code>lambda</code> are mandatory entries. If no constraints <code>lambda = []</code>.  </li><li>The constructor check the size of the entries.  </li></ul><p>See also: <code>GenericState</code>, <code>update!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code>, <code>reinit!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/NLPAtXmod.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.OneDAtX" href="#Stopping.OneDAtX"><code>Stopping.OneDAtX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: OneDAtX</p><p>Methods: update!, reinit!, copy</p><p>A structure designed to track line search information from one iteration to another. Given f : ℜⁿ → ℜ, define h(θ) = f(x + θ*d) where x and d are vectors of same dimension and θ is a scalar, more specifically the step size.</p><p>Tracked data can include:</p><ul><li>x             : the current step size</li><li>fx [opt]      : h(θ) at the current iteration</li><li>gx [opt]      : h&#39;(θ)</li><li>f₀ [opt]      : h(0)</li><li>g₀ [opt]      : h&#39;(0)</li><li>d [opt]       : search direction</li><li>res [opt]     : residual</li><li>current_time  : the time at which the line search algorithm started.</li><li>current_score : the score at which the line search algorithm started.</li></ul><p>Constructors:  <code>OneDAtX(:: T, :: S; fx :: T = _init_field(T), gx :: T = _init_field(T), f₀ :: T = _init_field(T), g₀ :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;: Number}</code></p><p><code>OneDAtX(:: T; fx :: T = _init_field(T), gx :: T = _init_field(T), f₀ :: T = _init_field(T), g₀ :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: T = _init_field(T))  where T &lt;: Number</code></p><p>Note: </p><ul><li>By default, unknown entries are set using <code>_init_field</code>.  </li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.  To have a vectorized <code>current_score</code> of length n, use <code>OneDAtX(x, Array{eltype(x),1}(undef, n))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/OneDAtXmod.jl#L1-L30">source</a></section></article><h2 id="General-Functions"><a class="docs-heading-anchor" href="#General-Functions">General Functions</a><a id="General-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.update!" href="#Stopping.update!"><code>Stopping.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`update!(:: AbstractState; convert = false, kwargs...)`</code></pre><p>Generic update function for the State The function compares the kwargs and the entries of the State. If the type of the kwargs is the same as the entry, then it is updated.</p><p>Set kargs <code>convert</code> to true to update even incompatible types.</p><p>Examples: <code>update!(state1)</code> <code>update!(state1, current_time = 2.0)</code> <code>update!(state1, convert = true, current_time = 2.0)</code></p><p>See also: <code>GenericState</code>, <code>reinit!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/GenericStatemod.jl#L85-L101">source</a></section><section><div><pre><code class="nohighlight hljs">`update!(stp::AbstractStopping; kwargs...)`</code></pre><p>update!: generic update function for the Stopping</p><p>Shortcut for update!(stp.current_state; kwargs...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L159-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.reinit!" href="#Stopping.reinit!"><code>Stopping.reinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`reinit!(:: AbstractState, :: T; kwargs...)`</code></pre><p>Function that set all the entries at <code>_init_field</code> except the mandatory <code>x</code>.</p><p>Note: If <code>x</code> is given as a kargs it will be prioritized over the second argument.</p><p>Examples: <code>reinit!(state2, zeros(2))</code> <code>reinit!(state2, zeros(2), current_time = 1.0)</code></p><p>There is a shorter version of reinit! reusing the <code>x</code> in the state</p><pre><code class="nohighlight hljs">`reinit!(:: AbstractState; kwargs...)`</code></pre><p>Examples: <code>reinit!(state2)</code> <code>reinit!(state2, current_time = 1.0)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/GenericStatemod.jl#L145-L164">source</a></section><section><div><p>reinit!: function that set all the entries at void except the mandatory x</p><p><code>reinit!(:: NLPAtX, x :: AbstractVector, l :: AbstractVector; kwargs...)</code></p><p><code>reinit!(:: NLPAtX; kwargs...)</code></p><p>Note: if <code>x</code> or <code>lambda</code> are given as keyword arguments they will be prioritized over the existing <code>x</code>, <code>lambda</code> and the default <code>Counters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/NLPAtXmod.jl#L159-L168">source</a></section><section><div><pre><code class="nohighlight hljs">`reinit!(:: AbstractStopping; rstate :: Bool = false, kwargs...)`</code></pre><p>Reinitialize the meta-data in the Stopping.</p><p>Note:</p><ul><li>If <code>rstate</code> is set as <code>true</code> it reinitializes the current State</li></ul><p>(with the kwargs).</p><ul><li>If <code>rlist</code> is set as true the list of states is also reinitialized, either</li></ul><p>set as a <code>VoidListofStates</code> if <code>rstate</code> is <code>true</code> or a list containing only the current state otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L266-L277">source</a></section><section><div><p>For NLPStopping, <code>rcounters</code> set as true also reinitialize the counters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/NLPStoppingmod.jl#L268-L270">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.copy, Stopping.compress_state!, Stopping.copy_compress_state</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.add_to_list!" href="#Stopping.add_to_list!"><code>Stopping.add_to_list!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>add_to_list!: add a State to the list of maximal size n. If a n+1-th State is added, the first one in the list is removed. The given is State is compressed before being added in the list (via State.copy_compress_state).</p><p><code>add_to_list!(:: AbstractListofStates, :: AbstractState; kwargs...)</code></p><p>Note: </p><ul><li>kwargs are passed to the compress_state call.</li><li>does nothing for <code>VoidListofStates</code></li></ul><p>see also: ListofStates, State.compress_state, State.copy_compress_state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/ListOfStates.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><p>length: return the number of States in the list.</p><p><code>length(:: ListofStates)</code></p><p>see also: print, add<em>to</em>list!, ListofStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/ListOfStates.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print" href="#Base.print"><code>Base.print</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print: output formatting. return a DataFrame.</p><p><code>print(:: ListofStates; verbose :: Bool = true, print_sym :: Union{Nothing,Array{Symbol,1}})</code></p><p>Note:</p><ul><li>set <code>verbose</code> to false to avoid printing.</li><li>if <code>print_sym</code> is an Array of Symbol, only those symbols are printed. Note that</li></ul><p>the returned DataFrame still contains all the columns.</p><ul><li>More information about DataFrame: http://juliadata.github.io/DataFrames.jl</li></ul><p>see also: add_to_list!, length, ListofStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/State/ListOfStates.jl#L114-L126">source</a></section></article><h1 id="Stopping"><a class="docs-heading-anchor" href="#Stopping">Stopping</a><a id="Stopping-1"></a><a class="docs-heading-anchor-permalink" href="#Stopping" title="Permalink"></a></h1><h2 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericStopping" href="#Stopping.GenericStopping"><code>Stopping.GenericStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: <code>GenericStopping</code></p><p>Methods: <code>start!</code>, <code>stop!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code>, <code>fill_in!</code>, <code>reinit!</code>, <code>status</code></p><p>A generic Stopping to solve instances with respect to some  optimality conditions. Optimality is decided by computing a score, which is then  tested to zero.</p><p>Tracked data include:</p><ul><li><code>pb</code>         : A problem</li><li><code>current_state</code> : The information relative to the problem, see <code>GenericState</code>.</li><li>(opt) <code>meta</code> : Metadata relative to a stopping criteria, see <code>StoppingMeta</code>.</li><li>(opt) <code>main_stp</code> : Stopping of the main loop in case we consider a Stopping                      of a subproblem.                      If not a subproblem, then <code>VoidStopping</code>.</li><li>(opt) <code>listofstates</code> : <code>ListofStates</code> designed to store the history of States.</li><li>(opt) <code>stopping_user_struct</code> : Contains a structure designed by the user.</li></ul><p>Constructors: </p><ul><li><code>GenericStopping(pb, meta::AbstractStoppingMeta, stop_remote::AbstractStopRemoteControl, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The default constructor.</li><li><code>GenericStopping(pb, meta::AbstractStoppingMeta, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>stop_remote</code>.</li><li><code>GenericStopping(pb, state::AbstractState; stop_remote::AbstractStopRemoteControl = StopRemoteControl(), main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>meta</code>.</li><li><code>GenericStopping(pb, stop_remote::AbstractStopRemoteControl, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>meta</code>.</li><li><code>GenericStopping(pb, x; n_listofstates=, kwargs...)</code>    The one setting up a default state using x, and initializing the list of states if <code>n_listofstates&gt;0</code>. </li></ul><p>Note: Metadata can be provided by the user or created with the Stopping        constructor via kwargs. If a specific StoppingMeta is given and        kwargs are provided, the kwargs have priority.</p><p>Examples:  <code>GenericStopping(pb, GenericState(ones(2)), rtol = 1e-1)</code></p><p>Besides optimality conditions, we consider classical emergency exit:</p><ul><li>domain error        (for instance: NaN in x)</li><li>unbounded problem   (not implemented)</li><li>unbounded x         (x is too large)</li><li>tired problem       (time limit attained)</li><li>resources exhausted (not implemented)</li><li>stalled problem     (not implemented)</li><li>iteration limit     (maximum number of iteration (i.e. nb of stop) attained)</li><li>main_pb limit       (tired or resources of main problem exhausted)</li></ul><p>There is an additional default constructor which creates a Stopping with a default State.</p><p><code>GenericStopping(:: Any, :: Union{Number, AbstractVector}; kwargs...)</code></p><p>Note: Keywords arguments are forwarded to the classical constructor.</p><p>Examples:  <code>GenericStopping(pb, x0, rtol = 1e-1)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L1-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPStopping" href="#Stopping.NLPStopping"><code>Stopping.NLPStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPStopping</p><p>Methods: <code>start!</code>, <code>stop!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code>, <code>fill_in!</code>, <code>reinit!</code>, <code>status</code>,  <code>KKT</code>, <code>unconstrained_check</code>, <code>optim_check_bounded</code></p><p>Specialization of <code>GenericStopping</code>. Stopping structure for non-linear optimization models using <code>NLPModels</code> ( https://github.com/JuliaSmoothOptimizers/NLPModels.jl ).</p><p>Attributes:</p><ul><li><code>pb</code>         : An <code>AbstractNLPModel</code>.</li><li><code>current_state</code>      : The information relative to the problem, see <code>GenericState</code> or <code>NLPAtX</code>.</li><li>(opt) <code>meta</code> : Metadata relative to stopping criteria, see <code>StoppingMeta</code>.</li><li>(opt) <code>main_stp</code> : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then <code>VoidStopping</code>.</li><li>(opt) <code>listofstates</code> : ListofStates designed to store the history of States.</li><li>(opt) <code>stopping_user_struct</code> : Contains any structure designed by the user.</li></ul><p>Constructors: </p><ul><li><code>NLPStopping(pb::AbstractNLPModel, meta::AbstractStoppingMeta, stop_remote::AbstractStopRemoteControl, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The default constructor.</li><li><code>NLPStopping(pb::AbstractNLPModel, meta::AbstractStoppingMeta, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>stop_remote</code>.</li><li><code>GenericStopping(pb::AbstractNLPModel, state::AbstractState; stop_remote::AbstractStopRemoteControl = StopRemoteControl(), main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>meta</code>.</li><li><code>GenericStopping(pb::AbstractNLPModel; n_listofstates=, kwargs...)</code>    The one setting up a default state <code>NLPAtX</code> using <code>pb.meta.x0</code>, and initializing the list of states if <code>n_listofstates&gt;0</code>. The optimality function is the function <code>KKT</code> unless <code>optimality_check</code> is in the <code>kwargs</code>.</li></ul><p>Notes:</p><ul><li>Designed for <code>NLPAtX</code> State. Constructor checks that the State has the required entries.</li></ul><pre><code class="nohighlight hljs"></code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/NLPStoppingmod.jl#L1-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LAStopping" href="#Stopping.LAStopping"><code>Stopping.LAStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LAStopping</p><p>Methods: <code>start!</code>, <code>stop!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code>, <code>fill_in!</code>, <code>reinit!</code>, <code>status</code>,  <code>linear_system_check</code>, <code>normal_equation_check</code></p><p>Specialization of GenericStopping. Stopping structure for linear algebra solving either</p><p><span>$Ax = b$</span></p><p>or</p><p class="math-container">\[min\_{x} \tfrac{1}{2}\|Ax - b\|^2\]</p><p>Attributes:</p><ul><li><code>pb</code>         : a problem using, for instance, either <code>LLSModel</code> (designed for linear least square problem, see https://github.com/JuliaSmoothOptimizers/LLSModels.jl ) or <code>LinearSystem</code>.</li><li><code>current_state</code>      : The information relative to the problem, see <code>GenericState</code>.</li><li>(opt) <code>meta</code> : Metadata relative to stopping criteria, see <code>StoppingMeta</code>.</li><li>(opt) <code>main_stp</code> : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then <code>VoidStopping</code>.</li><li>(opt) <code>listofstates</code> : ListofStates designed to store the history of States.</li><li>(opt) <code>stopping_user_struct</code> : Contains a structure designed by the user.</li></ul><p>Constructors: </p><ul><li><code>LAStopping(pb, meta::AbstractStoppingMeta, stop_remote::AbstractStopRemoteControl, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), zero_start::Bool = false)</code>    The default constructor.</li><li><code>LAStopping(pb, meta::AbstractStoppingMeta, state::AbstractState; main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), zero_start::Bool = false, kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>stop_remote</code>.</li><li><code>LAStopping(pb, state::AbstractState; stop_remote::AbstractStopRemoteControl = StopRemoteControl(), main_stp::AbstractStopping=VoidStopping(), list::AbstractListofStates = VoidListofStates(), user_struct::AbstractDict = Dict(), zero_start::Bool = false, kwargs...)</code>    The one passing the <code>kwargs</code> to the <code>meta</code>.</li><li><code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector; sparse::Bool = true, n_listofstates::Int = 0, kwargs...)</code>    The one setting up a default problem (<code>sparse ? LLSModel(A, b) : LinearSystem(A, b)</code>), a default <code>GenericState</code> using x, and initializing the list of states if <code>n_listofstates&gt;0</code>. </li><li><code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector, :: AbstractState; sparse::Bool = true, kwargs...)</code>    The one setting up a default problem (<code>sparse ? LLSModel(A, b) : LinearSystem(A, b)</code>). </li></ul><p>Notes:</p><ul><li>No specific State targeted</li><li>State don&#39;t necessarily keep track of evals</li><li>Evals are checked only for <code>pb.A</code> being a LinearOperator</li><li><code>zero_start</code> is true if 0 is the initial guess (not check automatically)</li><li><code>LLSModel</code> counter follow <code>NLSCounters</code> (see <code>init_max_counters_NLS</code>)</li><li>By default, <code>meta.max_cntrs</code> is initialized with an NLSCounters</li></ul><p>See also <code>GenericStopping</code>, <code>NLPStopping</code>, <code>linear_system_check</code>, <code>normal_equation_check</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/LinearAlgebraStopping.jl#L1-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LACounters" href="#Stopping.LACounters"><code>Stopping.LACounters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LACounters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/LinearAlgebraStopping.jl#L170-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.StoppingMeta" href="#Stopping.StoppingMeta"><code>Stopping.StoppingMeta</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: StoppingMeta</p><p>Methods: no methods.</p><p>Attributes:</p><ul><li><code>atol</code>: absolute tolerance.</li><li><code>rtol</code>: relative tolerance.</li><li><code>optimality0</code>: optimality score at the initial guess.</li><li><code>tol_check</code>: Function of <code>atol</code>, <code>rtol</code> and <code>optimality0</code> testing a score to zero.</li><li><code>tol_check_neg</code>: Function of <code>atol</code>, <code>rtol</code> and <code>optimality0</code> testing a score to zero.</li><li><code>check_pos</code>: pre-allocation for positive tolerance</li><li><code>check_neg</code>: pre-allocation for negative tolerance</li><li><code>recomp_tol</code>: true if tolerances are updated</li><li><code>optimality_check</code>: a stopping criterion via an admissibility function</li><li><code>unbounded_threshold</code>: threshold for unboundedness of the problem.</li><li><code>unbounded_x</code>: threshold for unboundedness of the iterate.</li><li><code>max_f</code>: maximum number of function (and derivatives) evaluations.</li><li><code>max_cntrs</code>: Dict contains the maximum number of evaluations</li><li><code>max_eval</code>:  maximum number of function (and derivatives) evaluations.</li><li><code>max_iter</code>: threshold on the number of stop! call/number of iteration.</li><li><code>max_time</code>: time limit to let the algorithm run.</li><li><code>nb_of_stop</code>: keep track of the number of stop! call/iteration.</li><li><code>start_time</code>: keep track of the time at the beginning.</li><li><code>fail_sub_pb</code>: status.</li><li><code>unbounded</code>: status.</li><li><code>unbounded_pb</code>: status.</li><li><code>tired</code>: status.</li><li><code>stalled</code>: status.</li><li><code>iteration_limit</code>: status.</li><li><code>resources</code>: status.</li><li><code>optimal</code>: status.</li><li><code>infeasible</code>: status.</li><li><code>main_pb</code>: status.</li><li><code>domainerror</code>: status.</li><li><code>suboptimal</code>: status.</li><li><code>stopbyuser</code>: status.</li><li><code>exception</code>: status.</li><li><code>meta_user_struct</code>:  Any</li><li><code>user_check_func!</code>: Function (AbstractStopping, Bool) -&gt; callback.</li></ul><p><code>StoppingMeta(;atol :: Number = 1.0e-6, rtol :: Number = 1.0e-15, optimality0 :: Number = 1.0, tol_check :: Function = (atol,rtol,opt0) -&gt; max(atol,rtol*opt0), tol_check_neg :: Function = (atol,rtol,opt0) -&gt; -max(atol,rtol*opt0), unbounded_threshold :: Number = 1.0e50, unbounded_x :: Number = 1.0e50, max_f :: Int = typemax(Int), max_eval :: Int = 20000, max_iter :: Int = 5000, max_time :: Number = 300.0, start_time :: Float64 = NaN, meta_user_struct :: Any = nothing, kwargs...)</code></p><p>an alternative with constant tolerances:</p><p><code>StoppingMeta(tol_check :: T, tol_check_neg :: T;atol :: Number = 1.0e-6, rtol :: Number = 1.0e-15, optimality0 :: Number = 1.0, unbounded_threshold :: Number = 1.0e50, unbounded_x :: Number = 1.0e50, max_f :: Int = typemax(Int), max_eval :: Int = 20000, max_iter :: Int = 5000, max_time :: Number = 300.0, start_time :: Float64 = NaN, meta_user_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>It is a mutable struct, therefore we can modify elements of a <code>StoppingMeta</code>.</li><li>The <code>nb_of_stop</code> is incremented everytime <code>stop!</code> or <code>update_and_stop!</code> is called</li><li>The <code>optimality0</code> is modified once at the beginning of the algorithm (<code>start!</code>)</li><li>The <code>start_time</code> is modified once at the beginning of the algorithm (<code>start!</code>)     if not precised before.</li><li>The different status: <code>fail_sub_pb</code>, <code>unbounded</code>, <code>unbounded_pb</code>, <code>tired</code>, <code>stalled</code>,     <code>iteration_limit</code>, <code>resources</code>, <code>optimal</code>, <code>main_pb</code>, <code>domainerror</code>, <code>suboptimal</code>, <code>infeasible</code></li><li><code>fail_sub_pb</code>, <code>suboptimal</code>, and <code>infeasible</code> are modified by the algorithm.</li><li><code>optimality_check</code> takes two inputs (<code>AbstractNLPModel</code>, <code>NLPAtX</code>)</li></ul><p>and returns a <code>Number</code> or an <code>AbstractVector</code> to be compared to <code>0</code>.</p><ul><li><code>optimality_check</code> does not necessarily fill in the State.</li></ul><p>Examples: <code>StoppingMeta()</code>, <code>StoppingMeta(1., -1.)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/StoppingMetamod.jl#L1-L62">source</a></section></article><h2 id="General-Functions-2"><a class="docs-heading-anchor" href="#General-Functions-2">General Functions</a><a class="docs-heading-anchor-permalink" href="#General-Functions-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.start!" href="#Stopping.start!"><code>Stopping.start!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`start!(stp::AbstractStopping; no_opt_check::Bool = false, kwargs...)`</code></pre><p>Update the Stopping and return <code>true</code> if we must stop.</p><p>Purpose is to know if there is a need to even perform an optimization algorithm or if we are at an optimal solution from the beginning.  Set <code>no_opt_check</code> to <code>true</code> avoid checking optimality and domain errors.</p><p>The function <code>start!</code> successively calls: <code>_domain_check(stp, x)</code>, <code>_optimality_check!(stp, x)</code>, <code>_null_test(stp, x)</code> and  <code>_user_check!(stp, x, true)</code>.</p><p>Note: - <code>start!</code> initializes <code>stp.meta.start_time</code> (if not done before), <code>stp.current_state.current_time</code> and <code>stp.meta.optimality0</code>  (if <code>no_opt_check</code> is false).           - Keywords argument are passed to the <code>_optimality_check!</code> call.           - Compatible with the <code>StopRemoteControl</code>.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L202-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_start!" href="#Stopping.update_and_start!"><code>Stopping.update_and_start!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`update_and_start!(stp::AbstractStopping; no_opt_check::Bool = false, kwargs...)`</code></pre><p>Update values in the State and initialize the Stopping. Returns the optimality status of the problem as a boolean.</p><p>Note: </p><ul><li>Kwargs are forwarded to the <code>update!</code> call.  </li><li><code>no_opt_check</code> skip optimality check in <code>start!</code> (<code>false</code> by default).  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L181-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.stop!" href="#Stopping.stop!"><code>Stopping.stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`stop!(:: AbstractStopping; kwargs...)`</code></pre><p>Update the Stopping and return a boolean true if we must stop.</p><p>It serves the same purpose as <code>start!</code> in an algorithm; telling us if we stop the algorithm (because we have reached optimality or we loop infinitely, etc).</p><p>The function <code>stop!</code> successively calls: <code>_domain_check</code>, <code>_optimality_check</code>, <code>_null_test</code>, <code>_unbounded_check!</code>, <code>_tired_check!</code>, <code>_resources_check!</code>, <code>_stalled_check!</code>, <code>_iteration_check!</code>, <code>_main_pb_check!</code>, <code>add_to_list!</code></p><p>Note:</p><ul><li>kwargs are sent to the <code>_optimality_check!</code> call.</li><li>If <code>listofstates != VoidListofStates</code>, call <code>add_to_list!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L321-L337">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_stop!" href="#Stopping.update_and_stop!"><code>Stopping.update_and_stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`update_and_stop!(stp :: AbstractStopping; kwargs...)`</code></pre><p>Update the values in the state and return the optimality status of the problem as a boolean.</p><p>Note: Kwargs are forwarded to the <code>update!</code> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L302-L308">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.reinit!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.fill_in!" href="#Stopping.fill_in!"><code>Stopping.fill_in!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`fill_in!(stp::AbstractStopping, x::T) where {T}`</code></pre><p>fill_in!: fill in the unspecified values of the AbstractState.</p><p>Note: NotImplemented for Abstract/Generic-Stopping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L170-L176">source</a></section><section><div><p>fill_in!: (NLPStopping version) a function that fill in the required values in the <code>NLPAtX</code>.</p><p><code>fill_in!( :: NLPStopping, :: Union{AbstractVector, Nothing}; fx :: Union{AbstractVector, Nothing} = nothing, gx :: Union{AbstractVector, Nothing} = nothing, Hx :: Union{MatrixType, Nothing} = nothing, cx :: Union{AbstractVector, Nothing} = nothing, Jx :: Union{MatrixType, Nothing} = nothing, lambda :: Union{AbstractVector, Nothing} = nothing, mu :: Union{AbstractVector, Nothing} = nothing, matrix_info :: Bool = true, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/NLPStoppingmod.jl#L204-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.status" href="#Stopping.status"><code>Stopping.status</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`status(:: AbstractStopping; list = false)`</code></pre><p>Returns the status of the algorithm:</p><p>The different statuses are:</p><ul><li><code>Optimal</code>: reached an optimal solution.</li><li><code>SubProblemFailure</code></li><li><code>SubOptimal</code>: reached an acceptable solution.</li><li><code>Unbounded</code>: current iterate too large in norm.</li><li><code>UnboundedPb</code>: unbouned problem.</li><li><code>Stalled</code>: stalled algorithm.</li><li><code>IterationLimit</code>: too many iterations of the algorithm.</li><li><code>TimeLimit</code>: time limit.</li><li><code>EvaluationLimit</code>: too many ressources used,                         i.e. too many functions evaluations.</li><li><code>ResourcesOfMainProblemExhausted</code>: in the case of a substopping, EvaluationLimit or TimeLimit for the main stopping.</li><li><code>Infeasible</code>: default return value, if nothing is done the problem is              considered feasible.</li><li><code>StopByUser</code>: stopped by the user.</li><li><code>DomainError</code>: there is a NaN somewhere.</li><li><code>Exception</code>: unhandled exception</li><li><code>Unknwon</code>: if stopped for reasons unknown by Stopping.</li></ul><p>Note:</p><ul><li>Set keyword argument <code>list</code> to true, to get an <code>Array</code> with all the statuses.   </li><li>The different statuses correspond to boolean values in the meta.   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/GenericStoppingmod.jl#L697-L725">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters" href="#Stopping.init_max_counters"><code>Stopping.init_max_counters</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters:  initialize the maximum number of evaluations on each of the functions present in the NLPModels.Counters, e.g.</p><p><code>init_max_counters(; allevals :: T = typemax(T), obj = allevals, grad = allevals, cons = allevals, jcon = allevals, jgrad = allevals, jac = allevals, jprod = allevals, jtprod = allevals, hess = allevals, hprod = allevals, jhprod = allevals, sum = 11 * allevals, kwargs...)</code></p><p><code>:neval_sum</code> is by default limited to <code>|Counters| * allevals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/NLPStoppingmod.jl#L139-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters_NLS" href="#Stopping.init_max_counters_NLS"><code>Stopping.init_max_counters_NLS</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters_NLS:  initialize the maximum number of evaluations on each of the functions present in the <code>NLPModels.NLSCounters</code>, e.g.</p><p><code>init_max_counters_NLS(; allevals = typemax(T), residual = allevals, jac_residual = allevals, jprod_residual = allevals, jtprod_residual = allevals, hess_residual = allevals, jhess_residual = allevals, hprod_residual = allevals, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/NLPStoppingmod.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters_linear_operators" href="#Stopping.init_max_counters_linear_operators"><code>Stopping.init_max_counters_linear_operators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters_linear_operators: counters for LinearOperator</p><p><code>init_max_counters_linear_operators(; allevals :: T = 20000, nprod = allevals, ntprod = allevals, nctprod = allevals, sum = 11 * allevals)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/LinearAlgebraStopping.jl#L188-L192">source</a></section></article><h2 id="Non-linear-admissibility-functions"><a class="docs-heading-anchor" href="#Non-linear-admissibility-functions">Non-linear admissibility functions</a><a id="Non-linear-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Non-linear-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.KKT" href="#Stopping.KKT"><code>Stopping.KKT</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`KKT( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)`</code></pre><p>Check the KKT conditions.</p><p>Note: <code>state.gx</code> is mandatory + if bounds <code>state.mu</code> + if constraints <code>state.cx</code>, <code>state.Jx</code>, <code>state.lambda</code>.</p><p>See also <code>unconstrained_check</code>, <code>optim_check_bounded</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/nlp_admissible_functions.jl#L104-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.unconstrained_check" href="#Stopping.unconstrained_check"><code>Stopping.unconstrained_check</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`unconstrained_check( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)`</code></pre><p>Return the <code>pnorm</code>-norm of the gradient of the objective function.</p><p>Require <code>state.gx</code> (filled if not provided).</p><p>See also <code>optim_check_bounded</code>, <code>KKT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/nlp_admissible_functions.jl#L3-L11">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.unconstrained2nd_check</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.optim_check_bounded" href="#Stopping.optim_check_bounded"><code>Stopping.optim_check_bounded</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`optim_check_bounded( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)`</code></pre><p>Check the <code>pnorm</code>-norm of the gradient of the objective function projected over the bounds.</p><p>Require <code>state.gx</code> (filled if not provided).</p><p>See also <code>unconstrained_check</code>, <code>KKT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/nlp_admissible_functions.jl#L25-L33">source</a></section></article><h2 id="Linear-algebra-admissibility-functions"><a class="docs-heading-anchor" href="#Linear-algebra-admissibility-functions">Linear algebra admissibility functions</a><a id="Linear-algebra-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-algebra-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.linear_system_check" href="#Stopping.linear_system_check"><code>Stopping.linear_system_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>linear_system_check: return ||Ax-b||_p</p><p><code>linear_system_check(:: Union{LinearSystem, LLSModel}, :: AbstractState; pnorm :: Real = Inf, kwargs...)</code></p><p>Note:</p><ul><li>Returns the p-norm of state.res</li><li>state.res is filled in if nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/LinearAlgebraStopping.jl#L301-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.normal_equation_check" href="#Stopping.normal_equation_check"><code>Stopping.normal_equation_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>normal_equation_check: return ||A&#39;Ax-A&#39;b||_p</p><p><code>normal_equation_check(:: Union{LinearSystem, LLSModel}, :: AbstractState; pnorm :: Real = Inf, kwargs...)</code></p><p>Note: pb must have A and b entries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/LinearAlgebraStopping.jl#L332-L338">source</a></section></article><h2 id="Line-search-admissibility-functions"><a class="docs-heading-anchor" href="#Line-search-admissibility-functions">Line search admissibility functions</a><a id="Line-search-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Line-search-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo" href="#Stopping.armijo"><code>Stopping.armijo</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`armijo(h::Any, h_at_t::OneDAtX{S, T}; τ₀::T = T(0.01), kwargs...) where {S, T}`</code></pre><p>Check if a step size is admissible according to the Armijo criterion.</p><p>Armijo criterion: <code>f(x + θd) - f(x) - τ₀ θ ∇f(x+θd)d &lt; 0</code></p><p>This function returns the maximum between the left-hand side and 0.</p><p>Note: <code>fx</code>, <code>f₀</code> and <code>g₀</code> are required in the <code>OneDAtX</code>.</p><p>See also <code>wolfe</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/ls_admissible_functions.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.wolfe" href="#Stopping.wolfe"><code>Stopping.wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`wolfe(h::Any, h_at_t::OneDAtX{S, T}; τ₁::T = T(0.99), kwargs...) where {S, T}`</code></pre><p>Check if a step size is admissible according to the Wolfe criterion.</p><p>Strong Wolfe criterion: <code>|∇f(x+θd)| - τ₁||∇f(x)|| &lt; 0</code>.</p><p>This function returns the maximum between the left-hand side and 0.</p><p>Note: <code>gx</code> and <code>g₀</code> are required in the <code>OneDAtX</code>.</p><p>See also <code>armijo</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/ls_admissible_functions.jl#L29-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo_wolfe" href="#Stopping.armijo_wolfe"><code>Stopping.armijo_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`armijo_wolfe(h::Any, h_at_t::OneDAtX{S, T}; τ₀::T = T(0.01), τ₁::T = T(0.99), kwargs...) where {S, T}`</code></pre><p>Check if a step size is admissible according to the Armijo and Wolfe criteria.</p><p>Note: <code>fx</code>, <code>f₀</code>, <code>gx</code> and <code>g₀</code> are required in the <code>OneDAtX</code>.</p><p>See also <code>armijo</code>, <code>wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/ls_admissible_functions.jl#L52-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.shamanskii_stop" href="#Stopping.shamanskii_stop"><code>Stopping.shamanskii_stop</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`shamanskii_stop(h :: Any, h_at_t :: OneDAtX; γ :: Float64 = 1.0e-09, kwargs...)`</code></pre><p>Check if a step size is admissible according to the &quot;Shamanskii&quot; criteria.</p><p>This criteria was proposed in:</p><blockquote><p>Lampariello, F., &amp; Sciandrone, M. (2001). Global convergence technique for the Newton method with periodic Hessian evaluation. Journal of optimization theory and applications, 111(2), 341-358.</p></blockquote><p>Note: </p><ul><li><code>h.d</code> accessible (specific <code>LineModel</code>).</li><li><code>fx</code>, <code>f₀</code> are required in the <code>OneDAtX</code>.</li></ul><p>See also <code>armijo</code>, <code>wolfe</code>, <code>armijo_wolfe</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/ls_admissible_functions.jl#L77-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.goldstein" href="#Stopping.goldstein"><code>Stopping.goldstein</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">`goldstein(h::Any, h_at_t::OneDAtX{S, T}; τ₀::T = T(0.0001), τ₁::T = T(0.9999), kwargs...) where {S, T}`</code></pre><p>Check if a step size is admissible according to the Goldstein criteria.</p><p>Note: <code>fx</code>, <code>f₀</code> and <code>g₀</code> are required in the <code>OneDAtX</code>.</p><p>See also <code>armijo</code>, <code>wolfe</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SolverStoppingJulia/Stopping.jl/blob/72cfa04e663acdd7123ac71c33e68ee8d0102042/src/Stopping/ls_admissible_functions.jl#L98-L106">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../idcard/">Stopping&#39;s ID »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Thursday 18 August 2022 19:55">Thursday 18 August 2022</span>. Using Julia version 1.8.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
