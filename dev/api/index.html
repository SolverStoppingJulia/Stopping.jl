<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Stopping.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Stopping.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions"><span>General Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Stopping"><span>Stopping</span></a></li><li><a class="tocitem" href="#Types-2"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions-2"><span>General Functions</span></a></li><li><a class="tocitem" href="#Non-linear-admissibility-functions"><span>Non-linear admissibility functions</span></a></li><li><a class="tocitem" href="#Linear-algebra-admissibility-functions"><span>Linear algebra admissibility functions</span></a></li><li><a class="tocitem" href="#Line-search-admissibility-functions"><span>Line search admissibility functions</span></a></li></ul></li><li><a class="tocitem" href="../idcard/">Stopping&#39;s ID</a></li><li><a class="tocitem" href="../idcard-state/">State&#39;s ID</a></li><li><a class="tocitem" href="../idcard-stoppingmeta/">Meta&#39;s ID</a></li><li><a class="tocitem" href="../howstopcheckoptimality/">Optimality in Stopping</a></li><li><a class="tocitem" href="../example-basic-Newton/">Stopping in action</a></li><li><a class="tocitem" href="../idcard-stopremote/">Stop remote control</a></li><li><a class="tocitem" href="../stop-workflow/">Stopping workflow</a></li><li><a class="tocitem" href="../speak-to-stopping/">Speak to stopping</a></li><li><a class="tocitem" href="../nlpstopping/">NLPStopping</a></li><li><a class="tocitem" href="../lastopping/">LAStopping</a></li><li><a class="tocitem" href="../index_tuto/">Readme</a></li><li><a class="tocitem" href="../howtostate/">How to State</a></li><li><a class="tocitem" href="../howtostate-nlp/">How to State for NLPs</a></li><li><a class="tocitem" href="../howtostop/">How to Stop</a></li><li><a class="tocitem" href="../howtostop-2/">How to Stop 2</a></li><li><a class="tocitem" href="../howtostop-nlp/">How to Stop for NLPs</a></li><li><a class="tocitem" href="../linear-algebra/">Solve linear algebra</a></li><li><a class="tocitem" href="../buffer/">Use a buffer function</a></li><li><a class="tocitem" href="../fixed-point/">A fixed point algorithm</a></li><li><a class="tocitem" href="../backls/">Backtracking linesearch algorithm</a></li><li><a class="tocitem" href="../uncons/">Unconstrained optimization algorithm</a></li><li><a class="tocitem" href="../active-set/">Active set algorithm</a></li><li><a class="tocitem" href="../penalty/">Quadratic penalty algorithm</a></li><li><a class="tocitem" href="../run-optimsolver/">Run optimization algorithms</a></li><li><a class="tocitem" href="../benchmark/">Benchmark optimization algorithms</a></li><li><a class="tocitem" href="../overfitting/">Overfitting</a></li><li><a class="tocitem" href="../checkpointing/">Checkpointing</a></li><li><a class="tocitem" href="../gradient-lbfgs/">Mix algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/vepiteski/Stopping.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericState" href="#Stopping.GenericState"><code>Stopping.GenericState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: GenericState</p><p>Methods: update!, reinit!</p><p>A generic State to describe the state of a problem at a point x.</p><p>Tracked data include:</p><ul><li>x             : current iterate</li><li>d [opt]       : search direction</li><li>res [opt]     : residual</li><li>current_time  : time</li><li>current_score : score</li></ul><p>Constructors:  <code>GenericState(:: T, :: S; d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;:AbstractVector}</code></p><p><code>GenericState(:: T; d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where T &lt;:AbstractVector</code></p><p>Note: </p><ul><li>By default, unknown entries are set using <code>_init_field</code>.</li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.  To have a vectorized <code>current_score</code> of length n, try something like <code>GenericState(x, Array{eltype(x),1}(undef, n))</code>.</li></ul><p>Examples:   GenericState(x)     GenericState(x, Array{eltype(x),1}(undef, length(x)))      GenericState(x, current_time = 1.0)      GenericState(x, current_score = 1.0)   </p><p>See also: Stopping, NLPAtX</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/GenericStatemod.jl#L16-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.ListofStates" href="#Stopping.ListofStates"><code>Stopping.ListofStates</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: list of States</p><p>Constructor:</p><p><code>ListofStates(:: AbstractState)</code></p><p><code>ListofStates(n :: Int, :: Val{AbstractState})</code></p><p><code>ListofStates(n :: Int, list :: Array{AbstractState,1})</code></p><p><code>ListofStates(state :: S; n :: Int = -1, kwargs...)</code></p><p>Note:</p><ul><li>If <code>n != -1</code>, then it stores at most n <code>AbstractState</code>.</li><li><code>ListofStates</code> recursively handles sub-list of states as the attribute list is</li></ul><p>an array of pair whose first component is a, <code>AbstractState</code> and the second component is a <code>ListofStates</code> (or <code>VoidListofStates</code>).</p><p>Examples: <code>ListofStates(state)</code>     <code>ListofStates(state, n = 2)</code>     <code>ListofStates(-1, Val{NLPAtX}())</code>     <code>ListofStates(-1, [(state1, VoidListofStates), (state2, VoidListofStates)], 2)</code>    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/ListOfStates.jl#L5-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPAtX" href="#Stopping.NLPAtX"><code>Stopping.NLPAtX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPAtX</p><p>Methods: update!, reinit!</p><p>NLPAtX contains the information concerning a nonlinear optimization model at the iterate x.</p><p>min_{x ∈ ℜⁿ} f(x) subject to lcon &lt;= c(x) &lt;= ucon, lvar &lt;= x &lt;= uvar.</p><p>Tracked data include:</p><ul><li><p>x             : the current iterate</p></li><li><p>fx [opt]      : function evaluation at x</p></li><li><p>gx [opt]      : gradient evaluation at x</p></li><li><p>Hx [opt]      : hessian evaluation at x</p></li><li><p>mu [opt]      : Lagrange multiplier of the bounds constraints</p></li><li><p>cx [opt]      : evaluation of the constraint function at x</p></li><li><p>Jx [opt]      : jacobian matrix of the constraint function at x</p></li><li><p>lambda        : Lagrange multiplier of the constraints</p></li><li><p>d [opt]       : search direction</p></li><li><p>res [opt]     : residual</p></li><li><p>current_time  : time</p></li><li><p>current_score : score</p></li></ul><p>(import the type NLPModels.Counters)</p><p>Constructors:  <code>NLPAtX(:: T, :: T, :: S; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), cx :: T = _init_field(T), Jx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;: AbstractVector}</code></p><p><code>NLPAtX(:: T; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where {T &lt;: AbstractVector}</code></p><p><code>NLPAtX(:: T, :: T; fx :: eltype(T) = _init_field(eltype(T)), gx :: T = _init_field(T), Hx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), mu :: T = _init_field(T), cx :: T = _init_field(T), Jx :: Matrix{eltype(T)} = _init_field(Matrix{eltype(T)}), d :: T = _init_field(T), res :: T = _init_field(T), current_time :: Float64  = NaN, current_score :: Union{T,eltype(T)} = _init_field(eltype(T))) where T &lt;: AbstractVector</code></p><p>Note:</p><ul><li>By default, unknown entries are set using <code>_init_field</code>.  </li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.    To have a vectorized <code>current_score</code> of length n, try something like <code>GenericState(x, Array{eltype(x),1}(undef, n))</code>.  </li><li>All these information (except for <code>x</code> and <code>lambda</code>) are optionnal and need to be update when  required. The update is done through the <code>update!</code> function.  </li><li><code>x</code> and <code>lambda</code> are mandatory entries. If no constraints <code>lambda = []</code>.  </li><li>The constructor check the size of the entries.  </li></ul><p>See also: <code>GenericState</code>, <code>update!</code>, <code>update_and_start!</code>, <code>update_and_stop!</code>, <code>reinit!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/NLPAtXmod.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.OneDAtX" href="#Stopping.OneDAtX"><code>Stopping.OneDAtX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: OneDAtX</p><p>Methods: update!, reinit!, copy</p><p>A structure designed to track line search information from one iteration to another. Given f : ℜⁿ → ℜ, define h(θ) = f(x + θ*d) where x and d are vectors of same dimension and θ is a scalar, more specifically the step size.</p><p>Tracked data can include:</p><ul><li>x             : the current step size</li><li>fx [opt]      : h(θ) at the current iteration</li><li>gx [opt]      : h&#39;(θ)</li><li>f₀ [opt]      : h(0)</li><li>g₀ [opt]      : h&#39;(0)</li><li>d [opt]       : search direction</li><li>res [opt]     : residual</li><li>current_time  : the time at which the line search algorithm started.</li><li>current_score : the score at which the line search algorithm started.</li></ul><p>Constructors:  <code>OneDAtX(:: T, :: S; fx :: T = _init_field(T), gx :: T = _init_field(T), f₀ :: T = _init_field(T), g₀ :: T = _init_field(T), current_time :: Float64 = NaN) where {S, T &lt;: Number}</code></p><p><code>OneDAtX(:: T; fx :: T = _init_field(T), gx :: T = _init_field(T), f₀ :: T = _init_field(T), g₀ :: T = _init_field(T), current_time :: Float64 = NaN, current_score :: T = _init_field(T))  where T &lt;: Number</code></p><p>Note: </p><ul><li>By default, unknown entries are set using <code>_init_field</code>.  </li><li>By default the type of <code>current_score</code> is <code>eltype(x)</code> and cannot be changed once the State is created.  To have a vectorized <code>current_score</code> of length n, use <code>OneDAtX(x, Array{eltype(x),1}(undef, n))</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/OneDAtXmod.jl#L1-L30">source</a></section></article><h2 id="General-Functions"><a class="docs-heading-anchor" href="#General-Functions">General Functions</a><a id="General-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.update!" href="#Stopping.update!"><code>Stopping.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update!: generic update function for the State</p><p><code>update!(:: AbstractState; convert = false, kwargs...)</code></p><p>The function compares the kwargs and the entries of the State. If the type of the kwargs is the same as the entry, then it is updated.</p><p>Set kargs <code>convert</code> to true to update even incompatible types.</p><p>Examples: update!(state1) update!(state1, current_time = 2.0) update!(state1, convert = true, current_time = 2.0)</p><p>See also: GenericState, reinit!, update_and_start!, update_and_stop!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/GenericStatemod.jl#L83-L100">source</a></section><section><div><p>update!: generic update function for the Stopping</p><p><code>update!(:: AbstractStopping; kwargs...)</code></p><p>Shortcut for update!(stp.current_state; kwargs...)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L140-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.reinit!" href="#Stopping.reinit!"><code>Stopping.reinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>reinit!: function that set all the entries at <code>_init_field</code> except the mandatory <code>x</code>.</p><p><code>reinit!(:: AbstractState, :: T; kwargs...)</code></p><p>Note: If <code>x</code> is given as a kargs it will be prioritized over the second argument.</p><p>Examples: reinit!(state2, zeros(2)) reinit!(state2, zeros(2), current_time = 1.0)</p><p>There is a shorter version of reinit! reusing the <code>x</code> in the state</p><p><code>reinit!(:: AbstractState; kwargs...)</code></p><p>Examples: reinit!(state2) reinit!(state2, current_time = 1.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/GenericStatemod.jl#L145-L164">source</a></section><section><div><p>reinit!: function that set all the entries at void except the mandatory x</p><p><code>reinit!(:: NLPAtX, x :: AbstractVector, l :: AbstractVector; kwargs...)</code></p><p><code>reinit!(:: NLPAtX; kwargs...)</code></p><p>Note: if <code>x</code> or <code>lambda</code> are given as keyword arguments they will be prioritized over the existing <code>x</code>, <code>lambda</code> and the default <code>Counters</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/NLPAtXmod.jl#L173-L182">source</a></section><section><div><p>reinit!: reinitialize the meta-data in the Stopping.</p><p><code>reinit!(:: AbstractStopping; rstate :: Bool = false, kwargs...)</code></p><p>Note:</p><ul><li>If <code>rstate</code> is set as <code>true</code> it reinitializes the current State</li></ul><p>(with the kwargs).</p><ul><li>If <code>rlist</code> is set as true the list of states is also reinitialized, either</li></ul><p>set as a <code>VoidListofStates</code> if <code>rstate</code> is <code>true</code> or a list containing only the current state otherwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L249-L260">source</a></section><section><div><p>For NLPStopping, <code>rcounters</code> set as true also reinitialize the counters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/NLPStoppingmod.jl#L238-L240">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.copy, Stopping.compress_state!, Stopping.copy_compress_state</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.add_to_list!" href="#Stopping.add_to_list!"><code>Stopping.add_to_list!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>add_to_list!: add a State to the list of maximal size n. If a n+1-th State is added, the first one in the list is removed. The given is State is compressed before being added in the list (via State.copy_compress_state).</p><p><code>add_to_list!(:: AbstractListofStates, :: AbstractState; kwargs...)</code></p><p>Note: </p><ul><li>kwargs are passed to the compress_state call.</li><li>does nothing for <code>VoidListofStates</code></li></ul><p>see also: ListofStates, State.compress_state, State.copy_compress_state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/ListOfStates.jl#L66-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><p>length: return the number of States in the list.</p><p><code>length(:: ListofStates)</code></p><p>see also: print, add<em>to</em>list!, ListofStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/ListOfStates.jl#L102-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print" href="#Base.print"><code>Base.print</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print: output formatting. return a DataFrame.</p><p><code>print(:: ListofStates; verbose :: Bool = true, print_sym :: Union{Nothing,Array{Symbol,1}})</code></p><p>Note:</p><ul><li>set <code>verbose</code> to false to avoid printing.</li><li>if <code>print_sym</code> is an Array of Symbol, only those symbols are printed. Note that</li></ul><p>the returned DataFrame still contains all the columns.</p><ul><li>More information about DataFrame: http://juliadata.github.io/DataFrames.jl</li></ul><p>see also: add_to_list!, length, ListofStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/State/ListOfStates.jl#L114-L126">source</a></section></article><h1 id="Stopping"><a class="docs-heading-anchor" href="#Stopping">Stopping</a><a id="Stopping-1"></a><a class="docs-heading-anchor-permalink" href="#Stopping" title="Permalink"></a></h1><h2 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericStopping" href="#Stopping.GenericStopping"><code>Stopping.GenericStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: GenericStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill_in!, reinit!, status</p><p>A generic Stopping to solve instances with respect to some  optimality conditions. Optimality is decided by computing a score, which is then  tested to zero.</p><p>Tracked data include:</p><ul><li>pb         : A problem</li><li>state      : The information relative to the problem, see <code>GenericState</code>.</li><li>(opt) meta : Metadata relative to a stopping criterion, see <code>StoppingMeta</code>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                      of a subproblem.                      If not a subproblem, then <code>nothing</code>.</li><li>(opt) listofstates : ListofStates designed to store the history of States.</li><li>(opt) stopping<em>user</em>struct : Contains any structure designed by the user.</li></ul><p>Constructor: <code>GenericStopping(:: Any, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta(), main_stp :: Union{AbstractStopping, Nothing} = nothing, stopping_user_struct :: Any = nothing, kwargs...)</code></p><p>Note: Metadata can be provided by the user or created with the Stopping        constructor via kwargs. If a specific StoppingMeta is given and        kwargs are provided, the kwargs have priority.</p><p>Examples:  GenericStopping(pb, GenericState(ones(2)), rtol = 1e-1)</p><p>Besides optimality conditions, we consider classical emergency exit:        - domain error        (for instance: NaN in x)        - unbounded problem   (not implemented)        - unbounded x         (x is too large)        - tired problem       (time limit attained)        - resources exhausted (not implemented)        - stalled problem     (not implemented)        - iteration limit     (maximum number of iteration (i.e. nb of stop) attained)        - main_pb limit       (tired or resources of main problem exhausted)</p><p>There is an additional default constructor which creates a Stopping with a default State.</p><p><code>GenericStopping(:: Any, :: Union{Number, AbstractVector}; kwargs...)</code></p><p>Note: Keywords arguments are forwarded to the classical constructor.</p><p>Examples:  GenericStopping(pb, x0, rtol = 1e-1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPStopping" href="#Stopping.NLPStopping"><code>Stopping.NLPStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill_in!, reinit!, status KKT, unconstrained_check, unconstrained2nd_check, optim_check_bounded</p><p>Specialization of GenericStopping. Stopping structure for non-linear programming problems using NLPModels.</p><p>Attributes:</p><ul><li>pb         : an AbstractNLPModel</li><li>state      : The information relative to the problem, see GenericState</li><li>(opt) meta : Metadata relative to stopping criterion, see <code>StoppingMeta</code>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then nothing.</li><li>(opt) listofstates : ListofStates designed to store the history of States.</li><li>(opt) stopping<em>user</em>struct : Contains any structure designed by the user.</li></ul><p><code>NLPStopping(:: AbstractNLPModel, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta(), max_cntrs :: Dict = init_max_counters(), main_stp :: Union{AbstractStopping, Nothing} = nothing, list :: Union{ListofStates, Nothing} = nothing, stopping_user_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>designed for <code>NLPAtX</code> State. Constructor checks that the State has the</li></ul><p>required entries.</p><p>There is an additional default constructor creating a Stopping where the State is by default and the  optimality function is the function <code>KKT()</code>`.</p><p><code>NLPStopping(pb :: AbstractNLPModel; kwargs...)</code></p><p>Note: Kwargs are forwarded to the classical constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/NLPStoppingmod.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LAStopping" href="#Stopping.LAStopping"><code>Stopping.LAStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LAStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill<em>in!, reinit!, status linear\</em>system_check, normal_equation_check</p><p>Specialization of GenericStopping. Stopping structure for linear algebra solving either</p><p><span>$Ax = b$</span></p><p>or</p><p><span>$min\_{x} \tfrac{1}{2}\|Ax - b\|^2$</span>.</p><p>Attributes:</p><ul><li>pb         : a problem using LLSModel (designed for linear least square problem, see https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/master/src/lls_model.jl )</li><li>state      : The information relative to the problem, see GenericState</li><li>(opt) meta : Metadata relative to stopping criterion, see <code>StoppingMeta</code>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then nothing.</li><li>(opt) listofstates : ListofStates designed to store the history of States.</li><li>(opt) stopping<em>user</em>struct : Contains any structure designed by the user.</li></ul><p><code>LAStopping(:: LLSModel, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta() main_stp :: Union{AbstractStopping, Nothing} = nothing, stopping_user_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>Kwargs are forwarded to the classical constructor.</li><li>Not specific State targeted</li><li>State don&#39;t necessarily keep track of evals</li><li>Evals are checked only for pb.A being a LinearOperator</li><li>zero_start is true if 0 is the initial guess (not check automatically)</li><li>LLSModel counter follow NLSCounters (see init<em>max</em>counters_NLS in NLPStoppingmod.jl)</li><li>By default, meta.max_cntrs is initialized with an NLSCounters</li></ul><p>There is additional constructors:</p><p><code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector, kwargs...)</code></p><p><code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector, :: AbstractState, kwargs...)</code></p><p>See also GenericStopping, NLPStopping, LS_Stopping, linear_system_check, normal_equation_check</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/LinearAlgebraStopping.jl#L1-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LACounters" href="#Stopping.LACounters"><code>Stopping.LACounters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LACounters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/LinearAlgebraStopping.jl#L156-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.StoppingMeta" href="#Stopping.StoppingMeta"><code>Stopping.StoppingMeta</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: StoppingMeta</p><p>Methods: no methods.</p><p>Attributes:</p><ul><li><p>atol: absolute tolerance.</p></li><li><p>rtol: relative tolerance.</p></li><li><p>optimality0: optimality score at the initial guess.</p></li><li><p>tol_check: Function of <code>atol</code>, <code>rtol</code> and <code>optimality0</code> testing a score to zero.</p></li><li><p>tol<em>check</em>neg: Function of <code>atol</code>, <code>rtol</code> and <code>optimality0</code> testing a score to zero.</p></li><li><p>check_pos: pre-allocation for positive tolerance</p></li><li><p>check_neg: pre-allocation for negative tolerance</p></li><li><p>recomp_tol: true if tolerances are updated</p></li><li><p>optimality_check: a stopping criterion via an admissibility function</p></li><li><p>unbounded_threshold: threshold for unboundedness of the problem.</p></li><li><p>unbounded_x: threshold for unboundedness of the iterate.</p></li><li><p>max_f: maximum number of function (and derivatives) evaluations.</p></li><li><p>max_cntrs: Dict contains the maximum number of evaluations</p></li><li><p>max_eval:  maximum number of function (and derivatives) evaluations.</p></li><li><p>max_iter: threshold on the number of stop! call/number of iteration.</p></li><li><p>max_time: time limit to let the algorithm run.</p></li><li><p>nb_of_stop: keep track of the number of stop! call/iteration.</p></li><li><p>start_time: keep track of the time at the beginning.</p></li><li><p>fail_sub_pb: status.</p></li><li><p>unbounded: status.</p></li><li><p>unbounded_pb: status.</p></li><li><p>tired: status.</p></li><li><p>stalled: status.</p></li><li><p>iteration_limit: status.</p></li><li><p>resources: status.</p></li><li><p>optimal: status.</p></li><li><p>infeasible: status.</p></li><li><p>main_pb: status.</p></li><li><p>domainerror: status.</p></li><li><p>suboptimal: status.</p></li><li><p>stopbyuser: status.</p></li><li><p>exception: status.</p></li><li><p>meta<em>user</em>struct:  Any</p></li><li><p>user<em>check</em>func!: Function (AbstractStopping, Bool) -&gt; callback.</p></li></ul><p><code>StoppingMeta(;atol :: Number = 1.0e-6, rtol :: Number = 1.0e-15, optimality0 :: Number = 1.0, tol_check :: Function = (atol,rtol,opt0) -&gt; max(atol,rtol*opt0), tol_check_neg :: Function = (atol,rtol,opt0) -&gt; -max(atol,rtol*opt0), unbounded_threshold :: Number = 1.0e50, unbounded_x :: Number = 1.0e50, max_f :: Int = typemax(Int), max_eval :: Int = 20000, max_iter :: Int = 5000, max_time :: Number = 300.0, start_time :: Float64 = NaN, meta_user_struct :: Any = nothing, kwargs...)</code></p><p>an alternative with constant tolerances:</p><p><code>StoppingMeta(tol_check :: T, tol_check_neg :: T;atol :: Number = 1.0e-6, rtol :: Number = 1.0e-15, optimality0 :: Number = 1.0, unbounded_threshold :: Number = 1.0e50, unbounded_x :: Number = 1.0e50, max_f :: Int = typemax(Int), max_eval :: Int = 20000, max_iter :: Int = 5000, max_time :: Number = 300.0, start_time :: Float64 = NaN, meta_user_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>It is a mutable struct, therefore we can modify elements of a <code>StoppingMeta</code>.</li><li>The <code>nb_of_stop</code> is incremented everytime <code>stop!</code> or <code>update_and_stop!</code> is called</li><li>The <code>optimality0</code> is modified once at the beginning of the algorithm (<code>start!</code>)</li><li>The <code>start_time</code> is modified once at the beginning of the algorithm (<code>start!</code>)     if not precised before.</li><li>The different status: <code>fail_sub_pb</code>, <code>unbounded</code>, <code>unbounded_pb</code>, <code>tired</code>, <code>stalled</code>,     <code>iteration_limit</code>, <code>resources</code>, <code>optimal</code>, <code>main_pb</code>, <code>domainerror</code>, <code>suboptimal</code>, <code>infeasible</code></li><li><code>fail_sub_pb</code>, <code>suboptimal</code>, and <code>infeasible</code> are modified by the algorithm.</li><li><code>optimality_check</code> takes two inputs (<code>AbstractNLPModel</code>, <code>NLPAtX</code>)</li></ul><p>and returns a <code>Number</code> or an <code>AbstractVector</code> to be compared to <code>0</code>.</p><ul><li><code>optimality_check</code> does not necessarily fill in the State.</li></ul><p>Examples: <code>StoppingMeta()</code>, <code>StoppingMeta(1., -1.)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/StoppingMetamod.jl#L1-L63">source</a></section></article><h2 id="General-Functions-2"><a class="docs-heading-anchor" href="#General-Functions-2">General Functions</a><a class="docs-heading-anchor-permalink" href="#General-Functions-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.start!" href="#Stopping.start!"><code>Stopping.start!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Update the Stopping and return <code>true</code> if we must stop.</p><p><code>start!(:: AbstractStopping; no_opt_check :: Bool = false, kwargs...)</code></p><p>Purpose is to know if there is a need to even perform an optimization algorithm  or if we are at an optimal solution from the beginning.   Set <code>no_opt_check</code> to <code>true</code> avoid checking optimality and domain errors.</p><p>The function <code>start!</code> successively calls: <code>_domain_check(stp, x)</code>,  <code>_optimality_check!(stp, x)</code>, <code>_null_test(stp, x)</code> and   <code>_user_check!(stp, x, true)</code>.</p><p>Note: - <code>start!</code> initializes <code>stp.meta.start_time</code> (if not done before),  <code>stp.current_state.current_time</code> and <code>stp.meta.optimality0</code>   (if <code>no_opt_check</code> is false).           - Keywords argument are passed to the <code>_optimality_check!</code> call.           - Compatible with the <code>StopRemoteControl</code>.   </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L183-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_start!" href="#Stopping.update_and_start!"><code>Stopping.update_and_start!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update_and_start!: update values in the State and initialize the Stopping. Returns the optimality status of the problem as a boolean.</p><p><code>update_and_start!(:: AbstractStopping; kwargs...)</code></p><p>Note: </p><ul><li>Kwargs are forwarded to the <code>update!</code> call.  </li><li><code>no_opt_check</code> skip optimality check in <code>start!</code> (<code>false</code> by default).  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L162-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.stop!" href="#Stopping.stop!"><code>Stopping.stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>stop!: update the Stopping and return a boolean true if we must stop.</p><p><code>stop!(:: AbstractStopping; kwargs...)</code></p><p>It serves the same purpose as <code>start!</code> in an algorithm; telling us if we stop the algorithm (because we have reached optimality or we loop infinitely, etc).</p><p>The function <code>stop!</code> successively calls: <code>_domain_check</code>, <code>_optimality_check</code>, <code>_null_test</code>, <code>_unbounded_check!</code>, <code>_tired_check!</code>, <code>_resources_check!</code>, <code>_stalled_check!</code>, <code>_iteration_check!</code>, <code>_main_pb_check!</code>, <code>add_to_list!</code></p><p>Note:</p><ul><li>kwargs are sent to the <code>_optimality_check!</code> call.</li><li>If <code>listofstates != VoidListofStates</code>, call <code>add_to_list!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L305-L321">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_stop!" href="#Stopping.update_and_stop!"><code>Stopping.update_and_stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update_and_stop!: update the values in the State and return the optimality status of the problem as a boolean.</p><p><code>update_and_stop!(stp :: AbstractStopping; kwargs...)</code></p><p>Note: Kwargs are forwarded to the <code>update!</code> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L285-L292">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.reinit!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.fill_in!" href="#Stopping.fill_in!"><code>Stopping.fill_in!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fill_in!: fill in the unspecified values of the AbstractState.</p><p><code>fill_in!(:: AbstractStopping, x :: Union{Number, AbstractVector})</code></p><p>Note: NotImplemented for Abstract/Generic-Stopping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L151-L157">source</a></section><section><div><p>fill_in!: (NLPStopping version) a function that fill in the required values in the <code>NLPAtX</code>.</p><p><code>fill_in!( :: NLPStopping, :: Union{AbstractVector, Nothing}; fx :: Union{AbstractVector, Nothing} = nothing, gx :: Union{AbstractVector, Nothing} = nothing, Hx :: Union{MatrixType, Nothing} = nothing, cx :: Union{AbstractVector, Nothing} = nothing, Jx :: Union{MatrixType, Nothing} = nothing, lambda :: Union{AbstractVector, Nothing} = nothing, mu :: Union{AbstractVector, Nothing} = nothing, matrix_info :: Bool = true, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/NLPStoppingmod.jl#L174-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.status" href="#Stopping.status"><code>Stopping.status</code></a> — <span class="docstring-category">Function</span></header><section><div><p>status: returns the status of the algorithm:</p><p><code>status(:: AbstractStopping; list = false)</code></p><p>The different statuses are:</p><ul><li>Optimal: reached an optimal solution.</li><li>SubProblemFailure</li><li>SubOptimal: reached an acceptable solution.</li><li>Unbounded: current iterate too large in norm.</li><li>UnboundedPb: unbouned problem.</li><li>Stalled: stalled algorithm.</li><li>IterationLimit: too many iterations of the algorithm.</li><li>TimeLimit: time limit.</li><li>EvaluationLimit: too many ressources used,                         i.e. too many functions evaluations.</li><li>ResourcesOfMainProblemExhausted: in the case of a substopping, EvaluationLimit or TimeLimit for the main stopping.</li><li>Infeasible: default return value, if nothing is done the problem is              considered feasible.</li><li>StopByUser: stopped by the user.</li><li>DomainError: there is a NaN somewhere.</li><li>Exception: unhandled exception</li><li>Unknwon: if stopped for reasons unknown by Stopping.</li></ul><p>Note:</p><ul><li>Set keyword argument <code>list</code> to true, to get an <code>Array</code> with all the statuses.   </li><li>The different statuses correspond to boolean values in the meta.   </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/GenericStoppingmod.jl#L686-L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters" href="#Stopping.init_max_counters"><code>Stopping.init_max_counters</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters:  initialize the maximum number of evaluations on each of the functions present in the NLPModels.Counters, e.g.</p><p><code>init_max_counters(; allevals :: T = typemax(T), obj = allevals, grad = allevals, cons = allevals, jcon = allevals, jgrad = allevals, jac = allevals, jprod = allevals, jtprod = allevals, hess = allevals, hprod = allevals, jhprod = allevals, sum = 11 * allevals, kwargs...)</code></p><p><code>:neval_sum</code> is by default limited to <code>|Counters| * allevals</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/NLPStoppingmod.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters_NLS" href="#Stopping.init_max_counters_NLS"><code>Stopping.init_max_counters_NLS</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters_NLS:  initialize the maximum number of evaluations on each of the functions present in the <code>NLPModels.NLSCounters</code>, e.g.</p><p><code>init_max_counters_NLS(; allevals = typemax(T), residual = allevals, jac_residual = allevals, jprod_residual = allevals, jtprod_residual = allevals, hess_residual = allevals, jhess_residual = allevals, hprod_residual = allevals, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/NLPStoppingmod.jl#L154-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.init_max_counters_linear_operators" href="#Stopping.init_max_counters_linear_operators"><code>Stopping.init_max_counters_linear_operators</code></a> — <span class="docstring-category">Function</span></header><section><div><p>init_max_counters_linear_operators: counters for LinearOperator</p><p><code>init_max_counters_linear_operators(; allevals :: T = 20000, nprod = allevals, ntprod = allevals, nctprod = allevals, sum = 11 * allevals)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/LinearAlgebraStopping.jl#L174-L178">source</a></section></article><h2 id="Non-linear-admissibility-functions"><a class="docs-heading-anchor" href="#Non-linear-admissibility-functions">Non-linear admissibility functions</a><a id="Non-linear-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Non-linear-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.KKT" href="#Stopping.KKT"><code>Stopping.KKT</code></a> — <span class="docstring-category">Function</span></header><section><div><p>KKT: verifies the KKT conditions</p><p><code>KKT( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)</code></p><p>Note: <code>state.gx</code> is mandatory + if bounds <code>state.mu</code> + if constraints <code>state.cx</code>, <code>state.Jx</code>, <code>state.lambda</code>.</p><p>See also <code>unconstrained_check</code>, <code>unconstrained2nd_check</code>, <code>optim_check_bounded</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/nlp_admissible_functions.jl#L117-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.unconstrained_check" href="#Stopping.unconstrained_check"><code>Stopping.unconstrained_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>unconstrained_check: return the infinite norm of the gradient of the objective function</p><p><code>unconstrained_check( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)</code></p><p>Require <code>state.gx</code> (filled if not provided)</p><p>See also <code>unconstrained2nd_check</code>, <code>optim_check_bounded</code>, <code>KKT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/nlp_admissible_functions.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.unconstrained2nd_check" href="#Stopping.unconstrained2nd_check"><code>Stopping.unconstrained2nd_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>unconstrained2nd_check: check the norm of the gradient and the smallest                    eigenvalue of the hessian.</p><p><code>unconstrained2nd_check( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)</code></p><p>Require are <code>state.gx</code>, <code>state.Hx</code> (filled if not provided).</p><p>See also <code>unconstrained_check</code>, <code>optim_check_bounded</code>, <code>KKT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/nlp_admissible_functions.jl#L20-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.optim_check_bounded" href="#Stopping.optim_check_bounded"><code>Stopping.optim_check_bounded</code></a> — <span class="docstring-category">Function</span></header><section><div><p>optim_check_bounded: gradient of the objective function projected</p><p><code>optim_check_bounded( :: AbstractNLPModel, :: NLPAtX; pnorm :: Real = Inf, kwargs...)</code></p><p>Require <code>state.gx</code> (filled if not provided).</p><p>See also <code>unconstrained_check</code>, <code>unconstrained2nd_check</code>, <code>KKT</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/nlp_admissible_functions.jl#L48-L56">source</a></section></article><h2 id="Linear-algebra-admissibility-functions"><a class="docs-heading-anchor" href="#Linear-algebra-admissibility-functions">Linear algebra admissibility functions</a><a id="Linear-algebra-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-algebra-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.linear_system_check" href="#Stopping.linear_system_check"><code>Stopping.linear_system_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>linear_system_check: return ||Ax-b||_p</p><p><code>linear_system_check(:: Union{LinearSystem, LLSModel}, :: AbstractState; pnorm :: Real = Inf, kwargs...)</code></p><p>Note:</p><ul><li>Returns the p-norm of state.res</li><li>state.res is filled in if nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/LinearAlgebraStopping.jl#L287-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.normal_equation_check" href="#Stopping.normal_equation_check"><code>Stopping.normal_equation_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>normal_equation_check: return ||A&#39;Ax-A&#39;b||_p</p><p><code>normal_equation_check(:: Union{LinearSystem, LLSModel}, :: AbstractState; pnorm :: Real = Inf, kwargs...)</code></p><p>Note: pb must have A and b entries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/LinearAlgebraStopping.jl#L323-L329">source</a></section></article><h2 id="Line-search-admissibility-functions"><a class="docs-heading-anchor" href="#Line-search-admissibility-functions">Line search admissibility functions</a><a id="Line-search-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Line-search-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo" href="#Stopping.armijo"><code>Stopping.armijo</code></a> — <span class="docstring-category">Function</span></header><section><div><p>armijo: check if a step size is admissible according to the Armijo criterion.</p><p>Armijo criterion: f(x + θd) - f(x) - τ₀ θ ∇f(x+θd)d &lt; 0</p><p><code>armijo(h :: Any, h_at_t :: OneDAtX; τ₀ :: Float64 = 0.01, kwargs...)</code></p><p>Note: fx, f₀ and g₀ are required in the OneDAtX</p><p>See also <code>wolfe</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/ls_admissible_functions.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.wolfe" href="#Stopping.wolfe"><code>Stopping.wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><p>wolfe: check if a step size is admissible according to the Wolfe criterion.</p><p>Strong Wolfe criterion: |∇f(x+θd)| &lt; τ₁||∇f(x)||.</p><p><code>wolfe(h :: Any, h_at_t :: OneDAtX; τ₁ :: Float64 = 0.99, kwargs...)</code></p><p>Note: gx and g₀ are required in the OneDAtX</p><p>See also <code>armijo</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/ls_admissible_functions.jl#L28-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo_wolfe" href="#Stopping.armijo_wolfe"><code>Stopping.armijo_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><p>armijo_wolfe: check if a step size is admissible according to the Armijo and Wolfe criteria.</p><p><code>armijo_wolfe(h :: Any, h_at_t :: OneDAtX; τ₀ :: Float64 = 0.01, τ₁ :: Float64 = 0.99, kwargs...)</code></p><p>Note: fx, f₀, gx and g₀ are required in the OneDAtX</p><p>See also <code>armijo</code>, <code>wolfe</code>, <code>shamanskii_stop</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/ls_admissible_functions.jl#L51-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.shamanskii_stop" href="#Stopping.shamanskii_stop"><code>Stopping.shamanskii_stop</code></a> — <span class="docstring-category">Function</span></header><section><div><p>shamanskii_stop: check if a step size is admissible according to the &quot;Shamanskii&quot; criteria. This criteria was proposed in: Lampariello, F., &amp; Sciandrone, M. (2001). Global convergence technique for the Newton method with periodic Hessian evaluation. Journal of optimization theory and applications, 111(2), 341-358.</p><p><code>shamanskii_stop(h :: Any, h_at_t :: OneDAtX; γ :: Float64 = 1.0e-09, kwargs...)</code></p><p>Note: </p><ul><li>h.d accessible (specific LineModel)</li><li>fx, f₀ are required in the OneDAtX</li></ul><p>See also <code>armijo</code>, <code>wolfe</code>, <code>armijo_wolfe</code>, <code>goldstein</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/ls_admissible_functions.jl#L70-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.goldstein" href="#Stopping.goldstein"><code>Stopping.goldstein</code></a> — <span class="docstring-category">Function</span></header><section><div><p>goldstein: check if a step size is admissible according to the Goldstein criteria.</p><p><code>goldstein(h :: Any, h_at_t :: OneDAtX; τ₀ :: Float64 = 0.0001, τ₁ :: Float64 = 0.9999, kwargs...)</code></p><p>Note: fx, f₀ and g₀ are required in the OneDAtX</p><p>See also <code>armijo</code>, <code>wolfe</code>, <code>armijo_wolfe</code>, <code>shamanskii_stop</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/7354c06fbc9fac3260675732cb375e80538410ac/src/Stopping/ls_admissible_functions.jl#L90-L98">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../idcard/">Stopping&#39;s ID »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 25 November 2021 13:10">Thursday 25 November 2021</span>. Using Julia version 1.6.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
