<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Stopping.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Stopping.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions"><span>General Functions</span></a></li><li class="toplevel"><a class="tocitem" href="#Stopping"><span>Stopping</span></a></li><li><a class="tocitem" href="#Types-2"><span>Types</span></a></li><li><a class="tocitem" href="#General-Functions-2"><span>General Functions</span></a></li><li><a class="tocitem" href="#Non-linear-admissibility-functions"><span>Non-linear admissibility functions</span></a></li><li><a class="tocitem" href="#Linear-algebra-admissibility-functions"><span>Linear algebra admissibility functions</span></a></li><li><a class="tocitem" href="#Line-search-admissibility-functions"><span>Line search admissibility functions</span></a></li></ul></li><li><a class="tocitem" href="../tutorial/">Examples and tutorials</a></li><li><a class="tocitem" href="../howtostate/">How to State</a></li><li><a class="tocitem" href="../howtostate-nlp/">How to State for NLPs</a></li><li><a class="tocitem" href="../howtostop/">How to Stop</a></li><li><a class="tocitem" href="../howtostop-2/">How to Stop 2</a></li><li><a class="tocitem" href="../howtostop-nlp/">How to Stop for NLPs</a></li><li><a class="tocitem" href="../linear-algebra/">Solve linear algebra</a></li><li><a class="tocitem" href="../buffer/">Use a buffer function</a></li><li><a class="tocitem" href="../fixed-point/">A fixed point algorithm</a></li><li><a class="tocitem" href="../backls/">Backtracking linesearch algorithm</a></li><li><a class="tocitem" href="../uncons/">Unconstrained optimization algorithm</a></li><li><a class="tocitem" href="../active-set/">Active set algorithm</a></li><li><a class="tocitem" href="../penalty/">Quadratic penalty algorithm</a></li><li><a class="tocitem" href="../run-optimsolver/">Run optimization algorithms</a></li><li><a class="tocitem" href="../benchmark/">Benchmark optimization algorithms</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/vepiteski/Stopping.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="State"><a class="docs-heading-anchor" href="#State">State</a><a id="State-1"></a><a class="docs-heading-anchor-permalink" href="#State" title="Permalink"></a></h1><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericState" href="#Stopping.GenericState"><code>Stopping.GenericState</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: GenericState</p><p>Methods: update!, reinit!</p><p>A generic State to describe the state of a problem at a point x.</p><p>Tracked data include:</p><ul><li>x                   : current iterate</li><li>d [opt]             : search direction</li><li>res [opt]           : residual</li><li>current_time [opt]  : time</li><li>current_score [opt] : score</li></ul><p>Constructor: <code>GenericState(:: AbstractVector; d :: Iterate = nothing, res :: Iterate = nothing, current_time :: FloatVoid = nothing, current_score :: Iterate = nothing)</code></p><p>Note: By default, unknown entries are set to <em>nothing</em>.</p><p>Examples: GenericState(x) GenericState(x, current_time = 1.0) GenericState(x, current_score = 1.0)</p><p>See also: Stopping, NLPAtX</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/GenericStatemod.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.ListStates" href="#Stopping.ListStates"><code>Stopping.ListStates</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: list of States</p><p>Constructor:</p><p><code>ListStates(:: AbstractState)</code></p><p>Note:</p><ul><li>If n != -1, then it stores at most n AbstractState.</li><li>add additional methods following https://docs.julialang.org/en/v1/base/collections/</li><li>ListStates recursively handles sub-list of states as the attribute list is</li></ul><p>an array of pair whose first component is a, AbstractState and the second component is a ListStates (or nothing).</p><p>Examples: ListStates(state) ListStates(state, n = 2) ListStates(n = -1, list = [[state1, nothing], [state2, nothing]], i = 2) ListStates(n = -1, list = [[state1, another_list]], i = 1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/ListOfStates.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPAtX" href="#Stopping.NLPAtX"><code>Stopping.NLPAtX</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPAtX</p><p>Methods: update!, reinit!</p><p>NLPAtX contains the information concerning a nonlinear optimization model at the iterate x.</p><p>min_{x ∈ ℜⁿ} f(x) subject to lcon &lt;= c(x) &lt;= ucon, lvar &lt;= x &lt;= uvar.</p><p>Tracked data include:</p><ul><li><p>x : the current iterate</p></li><li><p>fx [opt] : function evaluation at x</p></li><li><p>gx [opt] : gradient evaluation at x</p></li><li><p>Hx [opt] : hessian evaluation at x</p></li><li><p>mu [opt] : Lagrange multiplier of the bounds constraints</p></li><li><p>cx [opt] : evaluation of the constraint function at x</p></li><li><p>Jx [opt] : jacobian matrix of the constraint function at x</p></li><li><p>lambda   : Lagrange multiplier of the constraints</p></li><li><p>d [opt]   : search direction</p></li><li><p>res [opt] : residual</p></li><li><p>current_time [opt]  : time</p></li><li><p>current_score [opt] : score</p></li><li><p>evals [opt] : number of evaluations of the function (import the type NLPModels.Counters)</p></li></ul><p>Constructor: <code>NLPAtX(:: AbstractVector, :: AbstractVector; fx :: FloatVoid = nothing, gx :: Iterate = nothing, Hx :: MatrixType = nothing, mu :: Iterate = nothing, cx :: Iterate = nothing, Jx :: MatrixType = nothing, current_time :: FloatVoid = nothing, current_score :: Iterate = nothing, evals :: Counters = Counters())</code></p><p><code>NLPAtX(:: AbstractVector; fx :: FloatVoid = nothing, gx :: Iterate = nothing, Hx :: MatrixType = nothing, mu :: Iterate = nothing, current_time :: FloatVoid = nothing, current_score :: Iterate = nothing, evals :: Counters = Counters())</code></p><p>Note:       - By default, unknown entries are set to <em>nothing</em> (except evals).       - All these information (except for <em>x</em> and <em>lambda</em>) are optionnal and need to be update when         required. The update is done through the update! function.       - <em>x</em> and <em>lambda</em> are mandatory entries. If no constraints <code>lambda = []</code>.       - The constructor check the size of the entries.</p><p>See also: GenericState, update!, update_and_start!, update_and_stop!, reinit!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/NLPAtXmod.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LSAtT" href="#Stopping.LSAtT"><code>Stopping.LSAtT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LSAtT</p><p>Methods: update!, reinit!, copy</p><p>A structure designed to track line search information from one iteration to another. Given f : ℜⁿ → ℜ, define h(θ) = f(x + θ*d) where x and d are vectors of same dimension and θ is a scalar, more specifically the step size.</p><p>Tracked data can include:</p><ul><li>x : the current step size</li><li>ht [opt] : h(θ) at the current iteration</li><li>gt [opt] : h&#39;(θ)</li><li>h₀ [opt] : h(0)</li><li>g₀ [opt] : h&#39;(0)</li><li>current_time [opt]  :  the time at which the line search algorithm started.</li><li>current_score [opt] : the score at which the line search algorithm started.</li></ul><p>Constructor: <code>LSAtT(:: Number; ht :: FloatVoid = nothing, gt :: FloatVoid = nothing, h₀ :: FloatVoid = nothing, g₀ :: FloatVoid = nothing, current_time :: FloatVoid = nothing, current_score :: Iterate = nothing)</code></p><p>Note: By default, unknown entries are set to <em>nothing</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/LSAtTmod.jl#L1-L22">source</a></section></article><h2 id="General-Functions"><a class="docs-heading-anchor" href="#General-Functions">General Functions</a><a id="General-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#General-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.update!" href="#Stopping.update!"><code>Stopping.update!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update!: generic update function for the State</p><p><code>update!(:: AbstractState; convert = false, kwargs...)</code></p><p>The function compares the kwargs and the entries of the State. If the type of the kwargs is the same as the entry or the entry is <em>nothing</em>, then it is updated.</p><p>Set kargs <em>convert</em> to true to update even incompatible types.</p><p>Examples: update!(state1) update!(state1, current_time = 2.0) update!(state1, convert = true, current_time = 2.0)</p><p>See also: GenericState, reinit!, update_and_start!, update_and_stop!</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/GenericStatemod.jl#L48-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.reinit!" href="#Stopping.reinit!"><code>Stopping.reinit!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>reinit!: function that set all the entries at <em>nothing</em> except the mandatory <em>x</em>.</p><p><code>reinit!(:: AbstractState, :: Iterate; kwargs...)</code></p><p>Note: If <em>x</em> is given as a kargs it will be prioritized over the second argument.</p><p>Examples: reinit!(state2, zeros(2)) reinit!(state2, zeros(2), current_time = 1.0)</p><p>There is a shorter version of reinit! reusing the <em>x</em> in the state</p><p><code>reinit!(:: AbstractState; kwargs...)</code></p><p>Examples: reinit!(state2) reinit!(state2, current_time = 1.0)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/GenericStatemod.jl#L79-L98">source</a></section><section><div><p>reinit!: function that set all the entries at void except the mandatory x</p><p><code>reinit!(:: NLPAtX, x :: AbstractVector, l :: AbstractVector; kwargs...)</code></p><p><code>reinit!(:: NLPAtX; kwargs...)</code></p><p>Note: if <em>x</em>, <em>lambda</em> or <em>evals</em> are given as keyword arguments they will be prioritized over the existing <em>x</em>, <em>lambda</em> and the default <em>Counters</em>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/NLPAtXmod.jl#L104-L113">source</a></section><section><div><p>reinit!: reinitialize the MetaData in the Stopping.</p><p><code>reinit!(:: AbstractStopping; rstate :: Bool = false, kwargs...)</code></p><p>Note:</p><ul><li>If <em>rstate</em> is set as true it reinitializes the current State</li></ul><p>(with the kwargs).</p><ul><li>If <em>rlist</em> is set as true the list of states is also reinitialized, either</li></ul><p>set as nothing if <em>rstate</em> is true, and a list containing only the current state if <em>rstate</em> is false.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L161-L172">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.copy, Stopping.compress_state!, Stopping.copy_compress_state</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.add_to_list!" href="#Stopping.add_to_list!"><code>Stopping.add_to_list!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>add_to_list!: add a State to the list of maximal size n. If a n+1-th State is added, the first one in the list is removed. The given is State is compressed before being added in the list (via State.copy_compress_state).</p><p><code>add_to_list!(:: ListStates, :: AbstractState; kwargs...)</code></p><p>Note: kwargs are passed to the compress_state call.</p><p>see also: ListStates, State.compress_state, State.copy_compress_state</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/ListOfStates.jl#L41-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.length" href="#Base.length"><code>Base.length</code></a> — <span class="docstring-category">Function</span></header><section><div><p>length: return the number of States in the list.</p><p><code>length(:: ListStates)</code></p><p>see also: print, add<em>to</em>list!, ListStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/ListOfStates.jl#L72-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.print" href="#Base.print"><code>Base.print</code></a> — <span class="docstring-category">Function</span></header><section><div><p>print: output formatting. return a DataFrame.</p><p><code>print(:: ListStates; verbose :: Bool = true, print_sym :: Union{Nothing,Array{Symbol,1}})</code></p><p>Note:</p><ul><li>set <em>verbose</em> to false to avoid printing.</li><li>if <em>print_sym</em> is an Array of Symbol, only those symbols are printed. Note that</li></ul><p>the returned DataFrame still contains all the columns.</p><ul><li>More information about DataFrame: http://juliadata.github.io/DataFrames.jl</li></ul><p>see also: add_to_list!, length, ListStates</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/State/ListOfStates.jl#L84-L96">source</a></section></article><h1 id="Stopping"><a class="docs-heading-anchor" href="#Stopping">Stopping</a><a id="Stopping-1"></a><a class="docs-heading-anchor-permalink" href="#Stopping" title="Permalink"></a></h1><h2 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.GenericStopping" href="#Stopping.GenericStopping"><code>Stopping.GenericStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: GenericStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill_in!, reinit!, status</p><p>A generic Stopping to solve instances with respect to some  optimality conditions. Optimality is decided by computing a score, which is then  tested to zero.</p><p>Tracked data include:</p><ul><li>pb         : A problem</li><li>state      : The information relative to the problem, see <em>GenericState</em></li><li>(opt) meta : Metadata relative to a stopping criterion, see <em>StoppingMeta</em>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                      of a subproblem.                      If not a subproblem, then <em>nothing</em>.</li><li>(opt) listofstates : ListStates designed to store the history of States.</li><li>(opt) user<em>specific</em>struct : Contains any structure designed by the user.</li></ul><p>Constructor: <code>GenericStopping(:: Any, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta(), main_stp :: Union{AbstractStopping, Nothing} = nothing, user_specific_struct :: Any = nothing, kwargs...)</code></p><p>Note: Metadata can be provided by the user or created with the Stopping        constructor via kwargs. If a specific StoppingMeta is given and        kwargs are provided, the kwargs have priority.</p><p>Examples:  GenericStopping(pb, GenericState(ones(2)), rtol = 1e-1)</p><p>Besides optimality conditions, we consider classical emergency exit:        - domain error        (for instance: NaN in x)        - unbounded problem   (not implemented)        - unbounded x         (x is too large)        - tired problem       (time limit attained)        - resources exhausted (not implemented)        - stalled problem     (not implemented)        - iteration limit     (maximum number of iteration (i.e. nb of stop) attained)        - main_pb limit       (tired or resources of main problem exhausted)</p><p>There is an additional default constructor which creates a Stopping with a default State.</p><p><code>GenericStopping(:: Any, :: Union{Number, AbstractVector}; kwargs...)</code></p><p>Note: Keywords arguments are forwarded to the classical constructor.</p><p>Examples:  GenericStopping(pb, x0, rtol = 1e-1)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.NLPStopping" href="#Stopping.NLPStopping"><code>Stopping.NLPStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: NLPStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill_in!, reinit!, status KKT, unconstrained_check, unconstrained2nd_check, optim_check_bounded</p><p>Specialization of GenericStopping. Stopping structure for non-linear programming problems using NLPModels.</p><p>Attributes:</p><ul><li>pb         : an AbstractNLPModel</li><li>state      : The information relative to the problem, see GenericState</li><li>(opt) meta : Metadata relative to stopping criterion, see <em>StoppingMeta</em>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then nothing.</li><li>(opt) listofstates : ListStates designed to store the history of States.</li><li>(opt) user<em>specific</em>struct : Contains any structure designed by the user.</li></ul><p><code>NLPStopping(:: AbstractNLPModel, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta(), max_cntrs :: Dict = _init_max_counters(), main_stp :: Union{AbstractStopping, Nothing} = nothing, list :: Union{ListStates, Nothing} = nothing, user_specific_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>designed for <em>NLPAtX</em> State. Constructor checks that the State has the</li></ul><p>required entries.</p><p>There is an additional default constructor creating a Stopping where the State is by default and the  optimality function is the function <em>KKT()</em>.</p><p><code>NLPStopping(pb :: AbstractNLPModel; kwargs...)</code></p><p>Note: Kwargs are forwarded to the classical constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/NLPStoppingmod.jl#L1-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LS_Stopping" href="#Stopping.LS_Stopping"><code>Stopping.LS_Stopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LS_Stopping (specialization of GenericStopping)</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill_in!, reinit!, status, armijo, wolfe, armijo_wolfe, shamanskii_stop, goldstein</p><p>Specialization of GenericStopping. LS_Stopping is designed to handle the stopping criterion of line search problems. Let f:R→Rⁿ, then h(t) = f(x+td) where x and d are vectors and t is a scalar. h is such that h:R→R.</p><p>Stopping structure for 1D non-linear programming problems. Input :</p><ul><li>pb         : an Any</li><li>state      : The information relative to the problem, see GenericState</li><li>(opt) meta : Metadata relative to stopping criterion.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then nothing.</li><li>(opt) listofstates : ListStates designed to store the history of States.</li><li>(opt) user<em>specific</em>struct : Contains any structure designed by the user.</li></ul><p><code>LS_Stopping(:: Any, :: LSAtT; meta :: AbstractStoppingMeta = StoppingMeta(), main_stp :: Union{AbstractStopping, Nothing} = nothing, user_specific_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>The pb can be a LineModel defined in SolverTools.jl (https://github.com/JuliaSmoothOptimizers/SolverTools.jl)</li><li>It is possible to define those stopping criterion in a NLPStopping except NLPStopping uses vectors operations. LS_Stopping and it&#39;s admissible functions (Armijo and Wolfe are provided with Stopping.jl) uses scalar operations.</li><li>optimality_check(pb, state; kwargs...) -&gt; Float64 is by default <em>armijo</em> For instance, the armijo condition is: h(t)-h(0)-τ₀<em>t</em>h&#39;(0) ⩽ 0 therefore armijo(h, h<em>at</em>t) returns the maximum between h(t)-h(0)-τ₀<em>t</em>h&#39;(0) and 0.</li></ul><p>See also GenericStopping, NLPStopping, LSAtT</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/LineSearchStoppingmod.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LAStopping" href="#Stopping.LAStopping"><code>Stopping.LAStopping</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LAStopping</p><p>Methods: start!, stop!, update_and_start!, update_and_stop!, fill<em>in!, reinit!, status linear\</em>system_check, normal_equation_check</p><p>Specialization of GenericStopping. Stopping structure for linear algebra solving either</p><p><span>$Ax = b$</span></p><p>or</p><p><span>$min\_{x} \tfrac{1}{2}\|Ax - b\|^2$</span>.</p><p>Attributes:</p><ul><li>pb         : a problem using LLSModel (designed for linear least square problem, see https://github.com/JuliaSmoothOptimizers/NLPModels.jl/blob/master/src/lls_model.jl )</li><li>state      : The information relative to the problem, see GenericState</li><li>(opt) meta : Metadata relative to stopping criterion, see <em>StoppingMeta</em>.</li><li>(opt) main_stp : Stopping of the main loop in case we consider a Stopping                         of a subproblem.                         If not a subproblem, then nothing.</li><li>(opt) listofstates : ListStates designed to store the history of States.</li><li>(opt) user<em>specific</em>struct : Contains any structure designed by the user.</li></ul><p><code>LAStopping(:: LLSModel, :: AbstractState; meta :: AbstractStoppingMeta = StoppingMeta() main_stp :: Union{AbstractStopping, Nothing} = nothing, user_specific_struct :: Any = nothing, kwargs...)</code></p><p>Note:</p><ul><li>Kwargs are forwarded to the classical constructor.</li><li>Not specific State targeted</li><li>State don&#39;t necessarily keep track of evals</li><li>Evals are checked only for pb.A being a LinearOperator</li><li>zero_start is true if 0 is the initial guess (not check automatically)</li><li>LLSModel counter follow NLSCounters (see <em>init</em>max<em>counters</em>NLS in NLPStoppingmod.jl)</li><li>By default, meta.max_cntrs is initialized with an NLSCounters</li></ul><p>There is additional constructors:</p><p><code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector, kwargs...)</code> <code>LAStopping(:: Union{AbstractLinearOperator, AbstractMatrix}, :: AbstractVector, :: AbstractState, kwargs...)</code></p><p>See also GenericStopping, NLPStopping, LS_Stopping, linear_system_check, normal_equation_check</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/LinearAlgebraStopping.jl#L1-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.LACounters" href="#Stopping.LACounters"><code>Stopping.LACounters</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: LACounters</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/LinearAlgebraStopping.jl#L104-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.StoppingMeta" href="#Stopping.StoppingMeta"><code>Stopping.StoppingMeta</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Type: StoppingMeta</p><p>Methods: no methods.</p><p>Attributes:</p><ul><li>atol : absolute tolerance.</li><li>rtol : relative tolerance.</li><li>optimality0 : optimality score at the initial guess.</li><li>tol_check : Function of <em>atol</em>, <em>rtol</em> and <em>optimality0</em> testing a score to zero.</li><li>optimality_check : a stopping criterion via an admissibility function</li><li>unbounded_threshold : threshold for unboundedness of the problem.</li><li>unbounded_x : threshold for unboundedness of the iterate.</li><li>max_f :  maximum number of function (and derivatives) evaluations.</li><li>max_cntrs  : Dict contains the maximum number of evaluations</li><li>max_eval :  maximum number of function (and derivatives) evaluations.</li><li>max_iter : threshold on the number of stop! call/number of iteration.</li><li>max_time : time limit to let the algorithm run.</li><li>nb_of_stop : keep track of the number of stop! call/iteration.</li><li>start_time : keep track of the time at the beginning.</li><li>fail_sub_pb : status.</li><li>unbounded : status.</li><li>unbounded_pb : status.</li><li>tired : status.</li><li>stalled : status.</li><li>iteration_limit : status.</li><li>resources : status.</li><li>optimal : status.</li><li>infeasible : status.</li><li>main_pb : status.</li><li>domainerror : status.</li><li>suboptimal : status.</li></ul><p><code>StoppingMeta(;atol :: Number = 1.0e-6, rtol :: Number = 1.0e-15, optimality0 :: Number = 1.0, tol_check :: Function = (atol,rtol,opt0) -&gt; max(atol,rtol*opt0), unbounded_threshold :: Number = 1.0e50, unbounded_x :: Number = 1.0e50, max_f :: Int = typemax(Int), max_eval :: Int = 20000, max_iter :: Int = 5000, max_time :: Number = 300.0, start_time :: Float64 = NaN, kwargs...)</code></p><p>Note:</p><ul><li>It is a mutable struct, therefore we can modify elements of a <em>StoppingMeta</em>.</li><li>The <em>nb_of_stop</em> is incremented everytime <em>stop!</em> or <em>update_and_stop!</em> is called</li><li>The <em>optimality0</em> is modified once at the beginning of the algorithm (<em>start!</em>)</li><li>The <em>start_time</em> is modified once at the beginning of the algorithm (<em>start!</em>)     if not precised before.</li><li>The different status: <em>fail_sub_pb</em>, <em>unbounded</em>, <em>unbounded_pb</em>, <em>tired</em>, <em>stalled</em>,     <em>iteration_limit</em>, <em>resources</em>, <em>optimal</em>, <em>main_pb</em>, <em>domainerror</em>, <em>suboptimal</em>, <em>infeasible</em></li><li><em>fail_sub_pb</em>, <em>suboptimal</em>, and <em>infeasible</em> are modified by the algorithm.</li><li><em>optimality_check</em> takes two inputs (<em>AbstractNLPModel</em>, <em>NLPAtX</em>)</li></ul><p>and returns a <em>Number</em> to be compared to <em>0</em>.</p><ul><li><em>optimality_check</em> does not necessarily fill in the State.</li></ul><p>Examples: <code>StoppingMeta()</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/StoppingMetamod.jl#L1-L50">source</a></section></article><h2 id="General-Functions-2"><a class="docs-heading-anchor" href="#General-Functions-2">General Functions</a><a class="docs-heading-anchor-permalink" href="#General-Functions-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.start!" href="#Stopping.start!"><code>Stopping.start!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>start!: update the Stopping and return a boolean true if we must stop.</p><p><code>start!(:: AbstractStopping; no_start_opt_check :: Bool = false, kwargs...)</code></p><p>Purpose is to know if there is a need to even perform an optimization algorithm  or if we are at an optimal solution from the beginning. Set <em>no_start_opt_check</em>  to <em>true</em> to avoid checking optimality.</p><p>The function <em>start!</em> successively calls: <em>_domain_check</em>, <em>_optimality_check</em>,  <em>_null_test</em></p><p>Note: - <em>start!</em> initialize the start_time (if not done before) and <em>meta.optimality0</em>.        - Keywords argument are sent to the <em>_optimality_check!</em> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L115-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_start!" href="#Stopping.update_and_start!"><code>Stopping.update_and_start!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update_and_start!: update the values in the State and initialize the Stopping. Returns the optimality status of the problem as a boolean.</p><p><code>update_and_start!(:: AbstractStopping; kwargs...)</code></p><p>Note: Kwargs are forwarded to the <em>update!</em> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.stop!" href="#Stopping.stop!"><code>Stopping.stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>stop!: update the Stopping and return a boolean true if we must stop.</p><p><code>stop!(:: AbstractStopping; kwargs...)</code></p><p>It serves the same purpose as <em>start!</em> in an algorithm; telling us if we stop the algorithm (because we have reached optimality or we loop infinitely, etc).</p><p>The function <em>stop!</em> successively calls: <em>_domain_check</em>, <em>_optimality_check</em>, <em>_null_test</em>, <em>_unbounded_check!</em>, <em>_tired_check!</em>, <em>_resources_check!</em>, <em>_stalled_check!</em>, <em>_iteration_check!</em>, <em>_main_pb_check!</em>, add_to_list!</p><p>Note:</p><ul><li>Kwargs are sent to the <em>_optimality_check!</em> call.</li><li>If listofstates != nothing, call add_to_list! to update the list of State.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L226-L243">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.update_and_stop!" href="#Stopping.update_and_stop!"><code>Stopping.update_and_stop!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>update_and_stop!: update the values in the State and return the optimality status of the problem as a boolean.</p><p><code>update_and_stop!(stp :: AbstractStopping; kwargs...)</code></p><p>Note: Kwargs are forwarded to the <em>update!</em> call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L210-L217">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>Stopping.reinit!</code>. Check Documenter&#39;s build log for details.</p></div></div><article class="docstring"><header><a class="docstring-binding" id="Stopping.fill_in!" href="#Stopping.fill_in!"><code>Stopping.fill_in!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fill_in!: fill in the unspecified values of the AbstractState.</p><p><code>fill_in!(:: AbstractStopping, x :: Union{Number, AbstractVector})</code></p><p>Note: NotImplemented for Abstract/Generic-Stopping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L88-L94">source</a></section><section><div><p>fill_in!: (NLPStopping version) a function that fill in the required values in the <em>NLPAtX</em></p><p><code>fill_in!( :: NLPStopping, :: Iterate; fx :: Iterate = nothing, gx :: Iterate = nothing, Hx :: Iterate = nothing, cx :: Iterate = nothing, Jx :: Iterate = nothing, lambda :: Iterate = nothing, mu :: Iterate = nothing, matrix_info :: Bool = true, kwargs...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/NLPStoppingmod.jl#L146-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.status" href="#Stopping.status"><code>Stopping.status</code></a> — <span class="docstring-category">Function</span></header><section><div><p>status: returns the status of the algorithm:</p><p><code>status(:: AbstractStopping; list = false)</code></p><p>The different status are:</p><ul><li>Optimal: reached an optimal solution.</li><li>Unbounded: current iterate too large in norm.</li><li>UnboundedPb: unbouned problem.</li><li>Stalled: stalled algorithm.</li><li>IterationLimit: too many iterations of the algorithm.</li><li>Tired: algorithm too slow.</li><li>ResourcesExhausted: too many ressources used,                         i.e. too many functions evaluations.</li><li>ResourcesOfMainProblemExhausted: in the case of a substopping, ResourcesExhausted or Tired for the main stopping.</li><li>Infeasible: default return value, if nothing is done the problem is              considered feasible.</li><li>DomainError: there is a NaN somewhere.</li></ul><p>Note:</p><ul><li>Set keyword argument <em>list</em> to true, to get an Array with all the status.</li><li>The different status correspond to boolean values in the MetaData, see <em>StoppingMeta</em>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/GenericStoppingmod.jl#L526-L549">source</a></section></article><h2 id="Non-linear-admissibility-functions"><a class="docs-heading-anchor" href="#Non-linear-admissibility-functions">Non-linear admissibility functions</a><a id="Non-linear-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Non-linear-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.KKT" href="#Stopping.KKT"><code>Stopping.KKT</code></a> — <span class="docstring-category">Function</span></header><section><div><p>KKT: verifies the KKT conditions</p><p><code>KKT( :: AbstractNLPModel, :: NLPAtX; pnorm :: Float64 = Inf, kwargs...)</code></p><p>Note: <em>state.gx</em> is mandatory + if bounds <em>state.mu</em> + if constraints <em>state.cx</em>, <em>state.Jx</em>, <em>state.lambda</em>.</p><p>See also <em>unconstrained_check</em>, <em>unconstrained2nd_check</em>, <em>optim<em>check</em>bounded</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/nlp_admissible_functions.jl#L128-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.unconstrained_check" href="#Stopping.unconstrained_check"><code>Stopping.unconstrained_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>unconstrained: return the infinite norm of the gradient of the objective function</p><p><code>unconstrained_check( :: AbstractNLPModel, :: NLPAtX; pnorm :: Float64 = Inf, kwargs...)</code></p><p>required: state.gx (filled if nothing)</p><p>See also <em>unconstrained2nd_check</em>, <em>optim<em>check</em>bounded</em>, <em>KKT</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/nlp_admissible_functions.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.unconstrained2nd_check" href="#Stopping.unconstrained2nd_check"><code>Stopping.unconstrained2nd_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>unconstrained 2nd: check the norm of the gradient and the smallest                    eigenvalue of the hessian.</p><p><code>unconstrained2nd_check( :: AbstractNLPModel, :: NLPAtX; pnorm :: Float64 = Inf, kwargs...)</code></p><p>Note: required are <em>state.gx</em>, <em>state.Hx</em> (filled if <em>nothing</em>).</p><p>See also <em>unconstrained_check</em>, <em>optim<em>check</em>bounded</em>, <em>KKT</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/nlp_admissible_functions.jl#L26-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.optim_check_bounded" href="#Stopping.optim_check_bounded"><code>Stopping.optim_check_bounded</code></a> — <span class="docstring-category">Function</span></header><section><div><p>optim_check_bounded: gradient of the objective function projected</p><p><code>optim_check_bounded( :: AbstractNLPModel, :: NLPAtX; pnorm :: Float64 = Inf, kwargs...)</code></p><p>Note: required is <em>state.gx</em> (filled if <em>nothing</em>)</p><p>See also <em>unconstrained_check</em>, <em>unconstrained2nd_check</em>, <em>KKT</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/nlp_admissible_functions.jl#L54-L62">source</a></section></article><h2 id="Linear-algebra-admissibility-functions"><a class="docs-heading-anchor" href="#Linear-algebra-admissibility-functions">Linear algebra admissibility functions</a><a id="Linear-algebra-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-algebra-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.linear_system_check" href="#Stopping.linear_system_check"><code>Stopping.linear_system_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>linear_system_check: return ||Ax-b||_p</p><p><code>linear_system_check(:: Any, :: AbstractState; pnorm :: Float64 = Inf, kwargs...)</code></p><p>Note:</p><ul><li>Returns the p-norm of state.res</li><li>state.res is filled in if nothing.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/LinearAlgebraStopping.jl#L218-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.normal_equation_check" href="#Stopping.normal_equation_check"><code>Stopping.normal_equation_check</code></a> — <span class="docstring-category">Function</span></header><section><div><p>linear_system_check: return ||A&#39;Ax-A&#39;b||_p</p><p><code>linear_system_check(:: Any, :: AbstractState; pnorm :: Float64 = Inf, kwargs...)</code></p><p>Note: pb must have A and b entries</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/LinearAlgebraStopping.jl#L250-L256">source</a></section></article><h2 id="Line-search-admissibility-functions"><a class="docs-heading-anchor" href="#Line-search-admissibility-functions">Line search admissibility functions</a><a id="Line-search-admissibility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Line-search-admissibility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo" href="#Stopping.armijo"><code>Stopping.armijo</code></a> — <span class="docstring-category">Function</span></header><section><div><p>armijo: check if a step size is admissible according to the Armijo criterion.</p><p>Armijo criterion: f(x + θd) - f(x) - τ₀ θ ∇f(x+θd)d &lt; 0</p><p><code>armijo(h :: Any, h_at_t :: LSAtT; τ₀ :: Float64 = 0.01, kwargs...)</code></p><p>Note: ht, h₀ and g₀ are required in the LSAtT</p><p>See also <em>wolfe</em>, <em>armijo_wolfe</em>, <em>shamanskii_stop</em>, <em>goldstein</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/ls_admissible_functions.jl#L3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.wolfe" href="#Stopping.wolfe"><code>Stopping.wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><p>wolfe: check if a step size is admissible according to the Wolfe criterion.</p><p>Strong Wolfe criterion: |∇f(x+θd)| &lt; τ₁||∇f(x)||.</p><p><code>wolfe(h :: Any, h_at_t :: LSAtT; τ₁ :: Float64 = 0.99, kwargs...)</code></p><p>Note: gt and g₀ are required in the LSAtT</p><p>See also <em>armijo</em>, <em>armijo_wolfe</em>, <em>shamanskii_stop</em>, <em>goldstein</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/ls_admissible_functions.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.armijo_wolfe" href="#Stopping.armijo_wolfe"><code>Stopping.armijo_wolfe</code></a> — <span class="docstring-category">Function</span></header><section><div><p>armijo_wolfe: check if a step size is admissible according to the Armijo and Wolfe criteria.</p><p><code>armijo_wolfe(h :: Any, h_at_t :: LSAtT; τ₀ :: Float64 = 0.01, τ₁ :: Float64 = 0.99, kwargs...)</code></p><p>Note: ht, h₀, gt and g₀ are required in the LSAtT</p><p>See also <em>armijo</em>, <em>wolfe</em>, <em>shamanskii_stop</em>, <em>goldstein</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/ls_admissible_functions.jl#L61-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.shamanskii_stop" href="#Stopping.shamanskii_stop"><code>Stopping.shamanskii_stop</code></a> — <span class="docstring-category">Function</span></header><section><div><p>shamanskii_stop: check if a step size is admissible according to the &quot;Shamanskii&quot; criteria. This criteria was proposed in: Lampariello, F., &amp; Sciandrone, M. (2001). Global convergence technique for the Newton method with periodic Hessian evaluation. Journal of optimization theory and applications, 111(2), 341-358.</p><p><code>shamanskii_stop(h :: Any, h_at_t :: LSAtT; γ :: Float64 = 1.0e-09, kwargs...)</code></p><p>Note: * h.d accessible (specific LineModel)       * ht, h₀ are required in the LSAtT</p><p>See also <em>armijo</em>, <em>wolfe</em>, <em>armijo_wolfe</em>, <em>goldstein</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/ls_admissible_functions.jl#L86-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Stopping.goldstein" href="#Stopping.goldstein"><code>Stopping.goldstein</code></a> — <span class="docstring-category">Function</span></header><section><div><p>goldstein: check if a step size is admissible according to the Goldstein criteria.</p><p><code>goldstein(h :: Any, h_at_t :: LSAtT; τ₀ :: Float64 = 0.0001, τ₁ :: Float64 = 0.9999, kwargs...)</code></p><p>Note: ht, h₀ and g₀ are required in the LSAtT</p><p>See also <em>armijo</em>, <em>wolfe</em>, <em>armijo_wolfe</em>, <em>shamanskii_stop</em></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/vepiteski/Stopping.jl/blob/88712c0329db60d674aa12bbefcd5c83aff09c6c/src/Stopping/ls_admissible_functions.jl#L109-L117">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../tutorial/">Examples and tutorials »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 22 December 2020 01:13">Tuesday 22 December 2020</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
